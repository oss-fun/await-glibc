<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>self</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.12' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/18287.html#L47'>self</a>               47 htl/pt-create.c entry_point (struct __pthread *self, void *(*start_routine) (void *), void *arg)</span>
<span class='curline'><a href='../S/18287.html#L51'>self</a>               51 htl/pt-create.c   ___pthread_self = self;</span>
<span class='curline'><a href='../S/18287.html#L52'>self</a>               52 htl/pt-create.c   __resp = &amp;self-&gt;res_state;</span>
<span class='curline'><a href='../S/18287.html#L66'>self</a>               66 htl/pt-create.c   err = __pthread_sigstate (self, SIG_SETMASK, &amp;self-&gt;init_sigset, 0, 0);</span>
<span class='curline'><a href='../S/18287.html#L69'>self</a>               69 htl/pt-create.c   if (self-&gt;c11)</span>
<span class='curline'><a href='../S/18315.html#L35'>self</a>               35 htl/pt-exit.c    struct __pthread *self = _pthread_self ();</span>
<span class='curline'><a href='../S/18315.html#L61'>self</a>               61 htl/pt-exit.c    __pthread_mutex_lock (&amp;self-&gt;state_lock);</span>
<span class='curline'><a href='../S/18315.html#L63'>self</a>               63 htl/pt-exit.c    if (self-&gt;cancel_state == PTHREAD_CANCEL_ENABLE &amp;&amp; self-&gt;cancel_pending)</span>
<span class='curline'><a href='../S/18315.html#L66'>self</a>               66 htl/pt-exit.c    switch (self-&gt;state)</span>
<span class='curline'><a href='../S/18315.html#L74'>self</a>               74 htl/pt-exit.c        __pthread_mutex_unlock (&amp;self-&gt;state_lock);</span>
<span class='curline'><a href='../S/18315.html#L81'>self</a>               81 htl/pt-exit.c        self-&gt;state = PTHREAD_EXITED;</span>
<span class='curline'><a href='../S/18315.html#L85'>self</a>               85 htl/pt-exit.c        self-&gt;status = status;</span>
<span class='curline'><a href='../S/18315.html#L89'>self</a>               89 htl/pt-exit.c        __pthread_cond_broadcast (&amp;self-&gt;state_cond);</span>
<span class='curline'><a href='../S/18315.html#L90'>self</a>               90 htl/pt-exit.c        __pthread_mutex_unlock (&amp;self-&gt;state_lock);</span>
<span class='curline'><a href='../S/18315.html#L96'>self</a>               96 htl/pt-exit.c    __pthread_destroy_specific (self);</span>
<span class='curline'><a href='../S/18315.html#L99'>self</a>               99 htl/pt-exit.c    __pthread_sigstate_destroy (self);</span>
<span class='curline'><a href='../S/18315.html#L106'>self</a>              106 htl/pt-exit.c    __pthread_thread_terminate (self);</span>
<span class='curline'><a href='../S/18275.html#L27'>self</a>               27 htl/pt-self.c    struct __pthread *self = _pthread_self ();</span>
<span class='curline'><a href='../S/18275.html#L28'>self</a>               28 htl/pt-self.c    assert (self != NULL);</span>
<span class='curline'><a href='../S/18275.html#L30'>self</a>               30 htl/pt-self.c    return self-&gt;thread;</span>
<span class='curline'><a href='../S/18277.html#L27'>self</a>               27 htl/pt-sigmask.c   struct __pthread *self = _pthread_self ();</span>
<span class='curline'><a href='../S/18277.html#L30'>self</a>               30 htl/pt-sigmask.c   return __pthread_sigstate (self, how, set, oset, 0);</span>
<span class='curline'><a href='../S/2121.html#L170'>self</a>              170 hurd/hurd/signal.h       thread_t self = __mach_thread_self ();</span>
<span class='curline'><a href='../S/2121.html#L171'>self</a>              171 hurd/hurd/signal.h       THREAD_SETMEM (THREAD_SELF, _hurd_sigstate, _hurd_thread_sigstate (self));</span>
<span class='curline'><a href='../S/2121.html#L172'>self</a>              172 hurd/hurd/signal.h       __mach_port_deallocate (__mach_task_self (), self);</span>
<span class='curline'><a href='../S/2121.html#L221'>self</a>              221 hurd/hurd/signal.h       thread_t self = __mach_thread_self ();</span>
<span class='curline'><a href='../S/2121.html#L227'>self</a>              227 hurd/hurd/signal.h       ss = _hurd_thread_sigstate (self);</span>
<span class='curline'><a href='../S/2121.html#L229'>self</a>              229 hurd/hurd/signal.h       __mach_port_deallocate (__mach_task_self (), self);</span>
<span class='curline'><a href='../S/2105.html#L60'>self</a>               60 hurd/hurdkill.c 	  int self = 0;</span>
<span class='curline'><a href='../S/2105.html#L65'>self</a>               65 hurd/hurdkill.c 	      self = 1;</span>
<span class='curline'><a href='../S/2105.html#L77'>self</a>               77 hurd/hurdkill.c 	  if (self)</span>
<span class='curline'><a href='../S/1835.html#L139'>self</a>              139 malloc/tst-mallocfork3.c   pthread_t self = pthread_self ();</span>
<span class='curline'><a href='../S/1835.html#L141'>self</a>              141 malloc/tst-mallocfork3.c   struct signal_send_args sigusr2_args = { self, SIGUSR2, true };</span>
<span class='curline'><a href='../S/1835.html#L147'>self</a>              147 malloc/tst-mallocfork3.c   struct signal_send_args sigusr1_args = { self, SIGUSR1, false };</span>
<span class='curline'><a href='../S/18711.html#L32'>self</a>               32 nptl/cancellation.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18711.html#L34'>self</a>               34 nptl/cancellation.c   int oldval = THREAD_GETMEM (self, canceltype);</span>
<span class='curline'><a href='../S/18711.html#L35'>self</a>               35 nptl/cancellation.c   THREAD_SETMEM (self, canceltype, PTHREAD_CANCEL_ASYNCHRONOUS);</span>
<span class='curline'><a href='../S/18711.html#L37'>self</a>               37 nptl/cancellation.c   int ch = THREAD_GETMEM (self, cancelhandling);</span>
<span class='curline'><a href='../S/18711.html#L39'>self</a>               39 nptl/cancellation.c   if (self-&gt;cancelstate == PTHREAD_CANCEL_ENABLE</span>
<span class='curline'><a href='../S/18711.html#L44'>self</a>               44 nptl/cancellation.c       THREAD_SETMEM (self, result, PTHREAD_CANCELED);</span>
<span class='curline'><a href='../S/18711.html#L62'>self</a>               62 nptl/cancellation.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18711.html#L63'>self</a>               63 nptl/cancellation.c   self-&gt;canceltype = PTHREAD_CANCEL_DEFERRED;</span>
<span class='curline'><a href='../S/18675.html#L27'>self</a>               27 nptl/cleanup.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18675.html#L30'>self</a>               30 nptl/cleanup.c   ibuf-&gt;priv.data.prev = THREAD_GETMEM (self, cleanup_jmp_buf);</span>
<span class='curline'><a href='../S/18675.html#L31'>self</a>               31 nptl/cleanup.c   ibuf-&gt;priv.data.cleanup = THREAD_GETMEM (self, cleanup);</span>
<span class='curline'><a href='../S/18675.html#L34'>self</a>               34 nptl/cleanup.c   THREAD_SETMEM (self, cleanup_jmp_buf, (struct pthread_unwind_buf *) buf);</span>
<span class='curline'><a href='../S/18371.html#L26'>self</a>               26 nptl/cleanup_compat.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18371.html#L30'>self</a>               30 nptl/cleanup_compat.c   buffer-&gt;__prev = THREAD_GETMEM (self, cleanup);</span>
<span class='curline'><a href='../S/18371.html#L32'>self</a>               32 nptl/cleanup_compat.c   THREAD_SETMEM (self, cleanup, buffer);</span>
<span class='curline'><a href='../S/18371.html#L41'>self</a>               41 nptl/cleanup_compat.c   struct pthread *self __attribute ((unused)) = THREAD_SELF;</span>
<span class='curline'><a href='../S/18371.html#L43'>self</a>               43 nptl/cleanup_compat.c   THREAD_SETMEM (self, cleanup, buffer-&gt;__prev);</span>
<span class='curline'><a href='../S/18694.html#L27'>self</a>               27 nptl/cleanup_defer.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18694.html#L30'>self</a>               30 nptl/cleanup_defer.c   ibuf-&gt;priv.data.prev = THREAD_GETMEM (self, cleanup_jmp_buf);</span>
<span class='curline'><a href='../S/18694.html#L31'>self</a>               31 nptl/cleanup_defer.c   ibuf-&gt;priv.data.cleanup = THREAD_GETMEM (self, cleanup);</span>
<span class='curline'><a href='../S/18694.html#L34'>self</a>               34 nptl/cleanup_defer.c   ibuf-&gt;priv.data.canceltype = THREAD_GETMEM (self, canceltype);</span>
<span class='curline'><a href='../S/18694.html#L35'>self</a>               35 nptl/cleanup_defer.c   THREAD_SETMEM (self, canceltype, PTHREAD_CANCEL_DEFERRED);</span>
<span class='curline'><a href='../S/18694.html#L38'>self</a>               38 nptl/cleanup_defer.c   THREAD_SETMEM (self, cleanup_jmp_buf, (struct pthread_unwind_buf *) buf);</span>
<span class='curline'><a href='../S/18694.html#L52'>self</a>               52 nptl/cleanup_defer.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18694.html#L55'>self</a>               55 nptl/cleanup_defer.c   THREAD_SETMEM (self, cleanup_jmp_buf, ibuf-&gt;priv.data.prev);</span>
<span class='curline'><a href='../S/18694.html#L57'>self</a>               57 nptl/cleanup_defer.c   THREAD_SETMEM (self, canceltype, ibuf-&gt;priv.data.canceltype);</span>
<span class='curline'><a href='../S/18440.html#L25'>self</a>               25 nptl/libc-cleanup.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18440.html#L27'>self</a>               27 nptl/libc-cleanup.c   buffer-&gt;__prev = THREAD_GETMEM (self, cleanup);</span>
<span class='curline'><a href='../S/18440.html#L30'>self</a>               30 nptl/libc-cleanup.c   buffer-&gt;__canceltype = THREAD_GETMEM (self, canceltype);</span>
<span class='curline'><a href='../S/18440.html#L31'>self</a>               31 nptl/libc-cleanup.c   THREAD_SETMEM (self, canceltype, PTHREAD_CANCEL_DEFERRED);</span>
<span class='curline'><a href='../S/18440.html#L33'>self</a>               33 nptl/libc-cleanup.c   THREAD_SETMEM (self, cleanup, buffer);</span>
<span class='curline'><a href='../S/18440.html#L40'>self</a>               40 nptl/libc-cleanup.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18440.html#L42'>self</a>               42 nptl/libc-cleanup.c   THREAD_SETMEM (self, cleanup, buffer-&gt;__prev);</span>
<span class='curline'><a href='../S/18440.html#L44'>self</a>               44 nptl/libc-cleanup.c   THREAD_SETMEM (self, canceltype, buffer-&gt;__canceltype);</span>
<span class='curline'><a href='../S/18608.html#L24'>self</a>               24 nptl/nptl_deallocate_tsd.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18608.html#L28'>self</a>               28 nptl/nptl_deallocate_tsd.c   if (THREAD_GETMEM (self, specific_used))</span>
<span class='curline'><a href='../S/18608.html#L39'>self</a>               39 nptl/nptl_deallocate_tsd.c           THREAD_SETMEM (self, specific_used, false);</span>
<span class='curline'><a href='../S/18608.html#L45'>self</a>               45 nptl/nptl_deallocate_tsd.c               level2 = THREAD_GETMEM_NC (self, specific, cnt);</span>
<span class='curline'><a href='../S/18608.html#L81'>self</a>               81 nptl/nptl_deallocate_tsd.c           if (THREAD_GETMEM (self, specific_used) == 0)</span>
<span class='curline'><a href='../S/18608.html#L90'>self</a>               90 nptl/nptl_deallocate_tsd.c               sizeof (self-&gt;specific_1stblock));</span>
<span class='curline'><a href='../S/18608.html#L98'>self</a>               98 nptl/nptl_deallocate_tsd.c           level2 = THREAD_GETMEM_NC (self, specific, cnt);</span>
<span class='curline'><a href='../S/18608.html#L104'>self</a>              104 nptl/nptl_deallocate_tsd.c               THREAD_SETMEM_NC (self, specific, cnt, NULL);</span>
<span class='curline'><a href='../S/18608.html#L108'>self</a>              108 nptl/nptl_deallocate_tsd.c       THREAD_SETMEM (self, specific_used, false);</span>
<span class='curline'><a href='../S/18543.html#L77'>self</a>               77 nptl/nptl_setxid.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18543.html#L81'>self</a>               81 nptl/nptl_setxid.c       flags = THREAD_GETMEM (self, cancelhandling);</span>
<span class='curline'><a href='../S/18543.html#L82'>self</a>               82 nptl/nptl_setxid.c       newval = THREAD_ATOMIC_CMPXCHG_VAL (self, cancelhandling,</span>
<span class='curline'><a href='../S/18543.html#L88'>self</a>               88 nptl/nptl_setxid.c   self-&gt;setxid_futex = 1;</span>
<span class='curline'><a href='../S/18543.html#L89'>self</a>               89 nptl/nptl_setxid.c   futex_wake (&amp;self-&gt;setxid_futex, 1, FUTEX_PRIVATE);</span>
<span class='curline'><a href='../S/18543.html#L185'>self</a>              185 nptl/nptl_setxid.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18543.html#L192'>self</a>              192 nptl/nptl_setxid.c       if (t == self)</span>
<span class='curline'><a href='../S/18543.html#L202'>self</a>              202 nptl/nptl_setxid.c       if (t == self)</span>
<span class='curline'><a href='../S/18543.html#L218'>self</a>              218 nptl/nptl_setxid.c           if (t == self)</span>
<span class='curline'><a href='../S/18543.html#L227'>self</a>              227 nptl/nptl_setxid.c           if (t == self)</span>
<span class='curline'><a href='../S/18543.html#L248'>self</a>              248 nptl/nptl_setxid.c       if (t == self)</span>
<span class='curline'><a href='../S/18543.html#L257'>self</a>              257 nptl/nptl_setxid.c       if (t == self)</span>
<span class='curline'><a href='../S/18651.html#L43'>self</a>               43 nptl/pthread_cancel.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18651.html#L45'>self</a>               45 nptl/pthread_cancel.c   int ch = atomic_load_relaxed (&amp;self-&gt;cancelhandling);</span>
<span class='curline'><a href='../S/18651.html#L47'>self</a>               47 nptl/pthread_cancel.c   if (self-&gt;cancelstate == PTHREAD_CANCEL_DISABLE</span>
<span class='curline'><a href='../S/18651.html#L53'>self</a>               53 nptl/pthread_cancel.c   THREAD_SETMEM (self, result, PTHREAD_CANCELED);</span>
<span class='curline'><a href='../S/18651.html#L55'>self</a>               55 nptl/pthread_cancel.c   if (self-&gt;canceltype == PTHREAD_CANCEL_ASYNCHRONOUS)</span>
<span class='curline'><a href='../S/18629.html#L26'>self</a>               26 nptl/pthread_cleanup_upto.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18629.html#L32'>self</a>               32 nptl/pthread_cleanup_upto.c   uintptr_t adj = (uintptr_t) self-&gt;stackblock + self-&gt;stackblock_size;</span>
<span class='curline'><a href='../S/18629.html#L35'>self</a>               35 nptl/pthread_cleanup_upto.c   for (cbuf = THREAD_GETMEM (self, cleanup);</span>
<span class='curline'><a href='../S/18629.html#L59'>self</a>               59 nptl/pthread_cleanup_upto.c   THREAD_SETMEM (self, cleanup, cbuf);</span>
<span class='curline'><a href='../S/18538.html#L666'>self</a>              666 nptl/pthread_create.c   pd-&gt;header.self = pd;</span>
<span class='curline'><a href='../S/18538.html#L680'>self</a>              680 nptl/pthread_create.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18538.html#L682'>self</a>              682 nptl/pthread_create.c 	       | (self-&gt;flags &amp; (ATTR_FLAG_SCHED_SET | ATTR_FLAG_POLICY_SET)));</span>
<span class='curline'><a href='../S/18538.html#L686'>self</a>              686 nptl/pthread_create.c   if ((int) THREAD_GETMEM_VOLATILE (self, rseq_area.cpu_id) &gt;= 0)</span>
<span class='curline'><a href='../S/18538.html#L695'>self</a>              695 nptl/pthread_create.c   pd-&gt;eventbuf = self-&gt;eventbuf;</span>
<span class='curline'><a href='../S/18538.html#L700'>self</a>              700 nptl/pthread_create.c   pd-&gt;schedpolicy = self-&gt;schedpolicy;</span>
<span class='curline'><a href='../S/18538.html#L701'>self</a>              701 nptl/pthread_create.c   pd-&gt;schedparam = self-&gt;schedparam;</span>
<span class='curline'><a href='../S/18606.html#L31'>self</a>               31 nptl/pthread_join_common.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18606.html#L32'>self</a>               32 nptl/pthread_join_common.c   atomic_compare_exchange_weak_acquire (&amp;arg, &amp;self, NULL);</span>
<span class='curline'><a href='../S/18606.html#L52'>self</a>               52 nptl/pthread_join_common.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18606.html#L57'>self</a>               57 nptl/pthread_join_common.c   if ((pd == self</span>
<span class='curline'><a href='../S/18606.html#L58'>self</a>               58 nptl/pthread_join_common.c        || (self-&gt;joinid == pd</span>
<span class='curline'><a href='../S/18606.html#L62'>self</a>               62 nptl/pthread_join_common.c       &amp;&amp; !(self-&gt;cancelstate == PTHREAD_CANCEL_ENABLE</span>
<span class='curline'><a href='../S/18606.html#L78'>self</a>               78 nptl/pthread_join_common.c 								   &amp;self,</span>
<span class='curline'><a href='../S/18560.html#L26'>self</a>               26 nptl/pthread_setcancelstate.c   volatile struct pthread *self;</span>
<span class='curline'><a href='../S/18560.html#L31'>self</a>               31 nptl/pthread_setcancelstate.c   self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18560.html#L34'>self</a>               34 nptl/pthread_setcancelstate.c     *oldstate = self-&gt;cancelstate;</span>
<span class='curline'><a href='../S/18560.html#L35'>self</a>               35 nptl/pthread_setcancelstate.c   self-&gt;cancelstate = state;</span>
<span class='curline'><a href='../S/18425.html#L29'>self</a>               29 nptl/pthread_setcanceltype.c   volatile struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18425.html#L32'>self</a>               32 nptl/pthread_setcanceltype.c     *oldtype = self-&gt;canceltype;</span>
<span class='curline'><a href='../S/18425.html#L33'>self</a>               33 nptl/pthread_setcanceltype.c   self-&gt;canceltype = type;</span>
<span class='curline'><a href='../S/18451.html#L26'>self</a>               26 nptl/pthread_setspecific.c   struct pthread *self;</span>
<span class='curline'><a href='../S/18451.html#L32'>self</a>               32 nptl/pthread_setspecific.c   self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18451.html#L43'>self</a>               43 nptl/pthread_setspecific.c       level2 = &amp;self-&gt;specific_1stblock[key];</span>
<span class='curline'><a href='../S/18451.html#L47'>self</a>               47 nptl/pthread_setspecific.c 	THREAD_SETMEM (self, specific_used, true);</span>
<span class='curline'><a href='../S/18451.html#L60'>self</a>               60 nptl/pthread_setspecific.c       level2 = THREAD_GETMEM_NC (self, specific, idx1st);</span>
<span class='curline'><a href='../S/18451.html#L74'>self</a>               74 nptl/pthread_setspecific.c 	  THREAD_SETMEM_NC (self, specific, idx1st, level2);</span>
<span class='curline'><a href='../S/18451.html#L81'>self</a>               81 nptl/pthread_setspecific.c       THREAD_SETMEM (self, specific_used, true);</span>
<span class='curline'><a href='../S/18554.html#L25'>self</a>               25 nptl/pthread_testcancel.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18554.html#L26'>self</a>               26 nptl/pthread_testcancel.c   int cancelhandling = THREAD_GETMEM (self, cancelhandling);</span>
<span class='curline'><a href='../S/18554.html#L27'>self</a>               27 nptl/pthread_testcancel.c   if (self-&gt;cancelstate == PTHREAD_CANCEL_ENABLE</span>
<span class='curline'><a href='../S/18554.html#L32'>self</a>               32 nptl/pthread_testcancel.c       THREAD_SETMEM (self, result, PTHREAD_CANCELED);</span>
<span class='curline'><a href='../S/18399.html#L55'>self</a>               55 nptl/tpp.c       struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18399.html#L56'>self</a>               56 nptl/tpp.c       struct priority_protection_data *tpp = THREAD_GETMEM (self, tpp);</span>
<span class='curline'><a href='../S/18399.html#L80'>self</a>               80 nptl/tpp.c           THREAD_SETMEM (self, tpp, tpp);</span>
<span class='curline'><a href='../S/18399.html#L119'>self</a>              119 nptl/tpp.c       lll_lock (self-&gt;lock, LLL_PRIVATE);</span>
<span class='curline'><a href='../S/18399.html#L125'>self</a>              125 nptl/tpp.c       if ((self-&gt;flags &amp; ATTR_FLAG_SCHED_SET) == 0)</span>
<span class='curline'><a href='../S/18399.html#L127'>self</a>              127 nptl/tpp.c           if (__sched_getparam (self-&gt;tid, &amp;self-&gt;schedparam) != 0)</span>
<span class='curline'><a href='../S/18399.html#L130'>self</a>              130 nptl/tpp.c     	self-&gt;flags |= ATTR_FLAG_SCHED_SET;</span>
<span class='curline'><a href='../S/18399.html#L133'>self</a>              133 nptl/tpp.c       if ((self-&gt;flags &amp; ATTR_FLAG_POLICY_SET) == 0)</span>
<span class='curline'><a href='../S/18399.html#L135'>self</a>              135 nptl/tpp.c           self-&gt;schedpolicy = __sched_getscheduler (self-&gt;tid);</span>
<span class='curline'><a href='../S/18399.html#L136'>self</a>              136 nptl/tpp.c           if (self-&gt;schedpolicy == -1)</span>
<span class='curline'><a href='../S/18399.html#L139'>self</a>              139 nptl/tpp.c     	self-&gt;flags |= ATTR_FLAG_POLICY_SET;</span>
<span class='curline'><a href='../S/18399.html#L144'>self</a>              144 nptl/tpp.c           struct sched_param sp = self-&gt;schedparam;</span>
<span class='curline'><a href='../S/18399.html#L150'>self</a>              150 nptl/tpp.c     	  if (__sched_setscheduler (self-&gt;tid, self-&gt;schedpolicy, &amp;sp) &lt; 0)</span>
<span class='curline'><a href='../S/18399.html#L155'>self</a>              155 nptl/tpp.c       lll_unlock (self-&gt;lock, LLL_PRIVATE);</span>
<span class='curline'><a href='../S/18399.html#L164'>self</a>              164 nptl/tpp.c       struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18399.html#L165'>self</a>              165 nptl/tpp.c       if ((self-&gt;flags &amp; (ATTR_FLAG_POLICY_SET | ATTR_FLAG_SCHED_SET))</span>
<span class='curline'><a href='../S/18399.html#L167'>self</a>              167 nptl/tpp.c         return self-&gt;schedparam.sched_priority;</span>
<span class='curline'><a href='../S/18399.html#L172'>self</a>              172 nptl/tpp.c       lll_lock (self-&gt;lock, LLL_PRIVATE);</span>
<span class='curline'><a href='../S/18399.html#L174'>self</a>              174 nptl/tpp.c       if ((self-&gt;flags &amp; ATTR_FLAG_SCHED_SET) == 0)</span>
<span class='curline'><a href='../S/18399.html#L176'>self</a>              176 nptl/tpp.c           if (__sched_getparam (self-&gt;tid, &amp;self-&gt;schedparam) != 0)</span>
<span class='curline'><a href='../S/18399.html#L179'>self</a>              179 nptl/tpp.c     	self-&gt;flags |= ATTR_FLAG_SCHED_SET;</span>
<span class='curline'><a href='../S/18399.html#L182'>self</a>              182 nptl/tpp.c       if ((self-&gt;flags &amp; ATTR_FLAG_POLICY_SET) == 0)</span>
<span class='curline'><a href='../S/18399.html#L184'>self</a>              184 nptl/tpp.c           self-&gt;schedpolicy = __sched_getscheduler (self-&gt;tid);</span>
<span class='curline'><a href='../S/18399.html#L185'>self</a>              185 nptl/tpp.c           if (self-&gt;schedpolicy == -1)</span>
<span class='curline'><a href='../S/18399.html#L188'>self</a>              188 nptl/tpp.c     	self-&gt;flags |= ATTR_FLAG_POLICY_SET;</span>
<span class='curline'><a href='../S/18399.html#L192'>self</a>              192 nptl/tpp.c         result = self-&gt;schedparam.sched_priority;</span>
<span class='curline'><a href='../S/18399.html#L194'>self</a>              194 nptl/tpp.c       lll_unlock (self-&gt;lock, LLL_PRIVATE);</span>
<span class='curline'><a href='../S/18469.html#L79'>self</a>               79 nptl/tst-setgetname.c   pthread_t self;</span>
<span class='curline'><a href='../S/18469.html#L90'>self</a>               90 nptl/tst-setgetname.c   self = pthread_self ();</span>
<span class='curline'><a href='../S/18469.html#L91'>self</a>               91 nptl/tst-setgetname.c   res = pthread_getname_np (self, name, TASK_COMM_LEN);</span>
<span class='curline'><a href='../S/18469.html#L122'>self</a>              122 nptl/tst-setgetname.c   res = pthread_setname_np (self, NEW_NAME);</span>
<span class='curline'><a href='../S/18469.html#L153'>self</a>              153 nptl/tst-setgetname.c   res = pthread_getname_np (self, name, TASK_COMM_LEN);</span>
<span class='curline'><a href='../S/18469.html#L157'>self</a>              157 nptl/tst-setgetname.c       res = pthread_setname_np (self, BIG_NAME);</span>
<span class='curline'><a href='../S/18469.html#L208'>self</a>              208 nptl/tst-setgetname.c   res = pthread_setname_np (self, LONGEST_NAME);</span>
<span class='curline'><a href='../S/18469.html#L243'>self</a>              243 nptl/tst-setgetname.c   res = pthread_getname_np (self, name, strlen (LONGEST_NAME));</span>
<span class='curline'><a href='../S/18469.html#L272'>self</a>              272 nptl/tst-setgetname.c   res = pthread_getname_np (self, name, strlen (LONGEST_NAME) + 1);</span>
<span class='curline'><a href='../S/18631.html#L45'>self</a>               45 nptl/unwind.c    struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18631.html#L46'>self</a>               46 nptl/unwind.c    struct _pthread_cleanup_buffer *curp = THREAD_GETMEM (self, cleanup);</span>
<span class='curline'><a href='../S/18631.html#L52'>self</a>               52 nptl/unwind.c    uintptr_t adj = (uintptr_t) self-&gt;stackblock + self-&gt;stackblock_size;</span>
<span class='curline'><a href='../S/18631.html#L89'>self</a>               89 nptl/unwind.c  	  THREAD_SETMEM (self, cleanup, curp);</span>
<span class='curline'><a href='../S/18631.html#L123'>self</a>              123 nptl/unwind.c    struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/18631.html#L127'>self</a>              127 nptl/unwind.c    THREAD_SETMEM (self, exc.exception_class, 0);</span>
<span class='curline'><a href='../S/18631.html#L128'>self</a>              128 nptl/unwind.c    THREAD_SETMEM (self, exc.exception_cleanup, &amp;unwind_cleanup);</span>
<span class='curline'><a href='../S/18631.html#L130'>self</a>              130 nptl/unwind.c    _Unwind_ForcedUnwind (&amp;self-&gt;exc, unwind_stop, ibuf);</span>
<span class='curline'><a href='../S/1297.html#L493'>self</a>              493 rt/aio_misc.c    pthread_t self = __pthread_self ();</span>
<span class='curline'><a href='../S/1297.html#L500'>self</a>              500 rt/aio_misc.c    __pthread_getschedparam (self, &amp;policy, &amp;param);</span>
<span class='curline'><a href='../S/1297.html#L526'>self</a>              526 rt/aio_misc.c  	      __pthread_setschedparam (self, policy, &amp;param);</span>
<span class='curline'><a href='../S/17052.html#L19'>self</a>               19 sysdeps/alpha/machine-gmon.h #define _MCOUNT_DECL(from, self) \</span>
<span class='curline'><a href='../S/17052.html#L20'>self</a>               20 sysdeps/alpha/machine-gmon.h  void __mcount (u_long from, u_long self)</span>
<span class='curline'><a href='../S/13828.html#L21'>self</a>               21 sysdeps/hppa/machine-gmon.h #define _MCOUNT_DECL(from, self) \</span>
<span class='curline'><a href='../S/13828.html#L22'>self</a>               22 sysdeps/hppa/machine-gmon.h  void _mcount (u_long from, u_long self)</span>
<span class='curline'><a href='../S/17106.html#L61'>self</a>               61 sysdeps/htl/pt-barrier-wait.c       struct __pthread *self = _pthread_self ();</span>
<span class='curline'><a href='../S/17106.html#L64'>self</a>               64 sysdeps/htl/pt-barrier-wait.c       __pthread_enqueue (&amp;barrier-&gt;__queue, self);</span>
<span class='curline'><a href='../S/17106.html#L67'>self</a>               67 sysdeps/htl/pt-barrier-wait.c       __pthread_block (self);</span>
<span class='curline'><a href='../S/17107.html#L103'>self</a>              103 sysdeps/htl/pt-cond-timedwait.c   struct __pthread *self = _pthread_self ();</span>
<span class='curline'><a href='../S/17107.html#L105'>self</a>              105 sysdeps/htl/pt-cond-timedwait.c   ctx.wakeup = self;</span>
<span class='curline'><a href='../S/17107.html#L116'>self</a>              116 sysdeps/htl/pt-cond-timedwait.c   __pthread_mutex_lock (&amp;self-&gt;cancel_lock);</span>
<span class='curline'><a href='../S/17107.html#L117'>self</a>              117 sysdeps/htl/pt-cond-timedwait.c   cancelled = (self-&gt;cancel_state == PTHREAD_CANCEL_ENABLE)</span>
<span class='curline'><a href='../S/17107.html#L118'>self</a>              118 sysdeps/htl/pt-cond-timedwait.c       &amp;&amp; self-&gt;cancel_pending;</span>
<span class='curline'><a href='../S/17107.html#L122'>self</a>              122 sysdeps/htl/pt-cond-timedwait.c       __pthread_mutex_unlock (&amp;self-&gt;cancel_lock);</span>
<span class='curline'><a href='../S/17107.html#L126'>self</a>              126 sysdeps/htl/pt-cond-timedwait.c   self-&gt;cancel_hook = cancel_hook;</span>
<span class='curline'><a href='../S/17107.html#L127'>self</a>              127 sysdeps/htl/pt-cond-timedwait.c   self-&gt;cancel_hook_arg = &amp;ctx;</span>
<span class='curline'><a href='../S/17107.html#L128'>self</a>              128 sysdeps/htl/pt-cond-timedwait.c   oldtype = self-&gt;cancel_type;</span>
<span class='curline'><a href='../S/17107.html#L131'>self</a>              131 sysdeps/htl/pt-cond-timedwait.c     self-&gt;cancel_type = PTHREAD_CANCEL_DEFERRED;</span>
<span class='curline'><a href='../S/17107.html#L138'>self</a>              138 sysdeps/htl/pt-cond-timedwait.c   __pthread_enqueue (&amp;cond-&gt;__queue, self);</span>
<span class='curline'><a href='../S/17107.html#L143'>self</a>              143 sysdeps/htl/pt-cond-timedwait.c   __pthread_mutex_unlock (&amp;self-&gt;cancel_lock);</span>
<span class='curline'><a href='../S/17107.html#L154'>self</a>              154 sysdeps/htl/pt-cond-timedwait.c     err = __pthread_timedblock (self, abstime, clock_id);</span>
<span class='curline'><a href='../S/17107.html#L158'>self</a>              158 sysdeps/htl/pt-cond-timedwait.c       __pthread_block (self);</span>
<span class='curline'><a href='../S/17107.html#L162'>self</a>              162 sysdeps/htl/pt-cond-timedwait.c   if (self-&gt;prevp == NULL)</span>
<span class='curline'><a href='../S/17107.html#L181'>self</a>              181 sysdeps/htl/pt-cond-timedwait.c       __pthread_dequeue (self);</span>
<span class='curline'><a href='../S/17107.html#L194'>self</a>              194 sysdeps/htl/pt-cond-timedwait.c     __pthread_block (self);</span>
<span class='curline'><a href='../S/17107.html#L198'>self</a>              198 sysdeps/htl/pt-cond-timedwait.c   __pthread_mutex_lock (&amp;self-&gt;cancel_lock);</span>
<span class='curline'><a href='../S/17107.html#L199'>self</a>              199 sysdeps/htl/pt-cond-timedwait.c   self-&gt;cancel_hook = NULL;</span>
<span class='curline'><a href='../S/17107.html#L200'>self</a>              200 sysdeps/htl/pt-cond-timedwait.c   self-&gt;cancel_hook_arg = NULL;</span>
<span class='curline'><a href='../S/17107.html#L201'>self</a>              201 sysdeps/htl/pt-cond-timedwait.c   self-&gt;cancel_type = oldtype;</span>
<span class='curline'><a href='../S/17107.html#L202'>self</a>              202 sysdeps/htl/pt-cond-timedwait.c   cancelled = (self-&gt;cancel_state == PTHREAD_CANCEL_ENABLE)</span>
<span class='curline'><a href='../S/17107.html#L203'>self</a>              203 sysdeps/htl/pt-cond-timedwait.c       &amp;&amp; self-&gt;cancel_pending;</span>
<span class='curline'><a href='../S/17107.html#L204'>self</a>              204 sysdeps/htl/pt-cond-timedwait.c   __pthread_mutex_unlock (&amp;self-&gt;cancel_lock);</span>
<span class='curline'><a href='../S/17112.html#L26'>self</a>               26 sysdeps/htl/pt-getspecific.c   struct __pthread *self;</span>
<span class='curline'><a href='../S/17112.html#L32'>self</a>               32 sysdeps/htl/pt-getspecific.c   self = _pthread_self ();</span>
<span class='curline'><a href='../S/17112.html#L33'>self</a>               33 sysdeps/htl/pt-getspecific.c   if (key &gt;= self-&gt;thread_specifics_size)</span>
<span class='curline'><a href='../S/17112.html#L36'>self</a>               36 sysdeps/htl/pt-getspecific.c   return self-&gt;thread_specifics[key];</span>
<span class='curline'><a href='../S/17095.html#L35'>self</a>               35 sysdeps/htl/pt-rwlock-timedrdlock.c   struct __pthread *self;</span>
<span class='curline'><a href='../S/17095.html#L71'>self</a>               71 sysdeps/htl/pt-rwlock-timedrdlock.c   self = _pthread_self ();</span>
<span class='curline'><a href='../S/17095.html#L74'>self</a>               74 sysdeps/htl/pt-rwlock-timedrdlock.c   __pthread_enqueue (&amp;rwlock-&gt;__readerqueue, self);</span>
<span class='curline'><a href='../S/17095.html#L79'>self</a>               79 sysdeps/htl/pt-rwlock-timedrdlock.c     err = __pthread_timedblock (self, abstime, clockid);</span>
<span class='curline'><a href='../S/17095.html#L83'>self</a>               83 sysdeps/htl/pt-rwlock-timedrdlock.c       __pthread_block (self);</span>
<span class='curline'><a href='../S/17095.html#L87'>self</a>               87 sysdeps/htl/pt-rwlock-timedrdlock.c   if (self-&gt;prevp == NULL)</span>
<span class='curline'><a href='../S/17095.html#L97'>self</a>               97 sysdeps/htl/pt-rwlock-timedrdlock.c       __pthread_dequeue (self);</span>
<span class='curline'><a href='../S/17095.html#L103'>self</a>              103 sysdeps/htl/pt-rwlock-timedrdlock.c     __pthread_block (self);</span>
<span class='curline'><a href='../S/17125.html#L35'>self</a>               35 sysdeps/htl/pt-rwlock-timedwrlock.c   struct __pthread *self;</span>
<span class='curline'><a href='../S/17125.html#L57'>self</a>               57 sysdeps/htl/pt-rwlock-timedwrlock.c   self = _pthread_self ();</span>
<span class='curline'><a href='../S/17125.html#L60'>self</a>               60 sysdeps/htl/pt-rwlock-timedwrlock.c   __pthread_enqueue (&amp;rwlock-&gt;__writerqueue, self);</span>
<span class='curline'><a href='../S/17125.html#L65'>self</a>               65 sysdeps/htl/pt-rwlock-timedwrlock.c     err = __pthread_timedblock (self, abstime, clockid);</span>
<span class='curline'><a href='../S/17125.html#L69'>self</a>               69 sysdeps/htl/pt-rwlock-timedwrlock.c       __pthread_block (self);</span>
<span class='curline'><a href='../S/17125.html#L73'>self</a>               73 sysdeps/htl/pt-rwlock-timedwrlock.c   if (self-&gt;prevp == NULL)</span>
<span class='curline'><a href='../S/17125.html#L83'>self</a>               83 sysdeps/htl/pt-rwlock-timedwrlock.c       __pthread_dequeue (self);</span>
<span class='curline'><a href='../S/17125.html#L89'>self</a>               89 sysdeps/htl/pt-rwlock-timedwrlock.c     __pthread_block (self);</span>
<span class='curline'><a href='../S/17153.html#L26'>self</a>               26 sysdeps/htl/pt-setspecific.c   struct __pthread *self = _pthread_self ();</span>
<span class='curline'><a href='../S/17153.html#L32'>self</a>               32 sysdeps/htl/pt-setspecific.c   if (key &gt;= self-&gt;thread_specifics_size)</span>
<span class='curline'><a href='../S/17153.html#L36'>self</a>               36 sysdeps/htl/pt-setspecific.c       void **new = realloc (self-&gt;thread_specifics,</span>
<span class='curline'><a href='../S/17153.html#L41'>self</a>               41 sysdeps/htl/pt-setspecific.c       memset (&amp;new[self-&gt;thread_specifics_size], 0,</span>
<span class='curline'><a href='../S/17153.html#L42'>self</a>               42 sysdeps/htl/pt-setspecific.c 	      (newsize - self-&gt;thread_specifics_size) * sizeof (new[0]));</span>
<span class='curline'><a href='../S/17153.html#L43'>self</a>               43 sysdeps/htl/pt-setspecific.c       self-&gt;thread_specifics = new;</span>
<span class='curline'><a href='../S/17153.html#L44'>self</a>               44 sysdeps/htl/pt-setspecific.c       self-&gt;thread_specifics_size = newsize;</span>
<span class='curline'><a href='../S/17153.html#L47'>self</a>               47 sysdeps/htl/pt-setspecific.c   self-&gt;thread_specifics[key] = (void *) value;</span>
<span class='curline'><a href='../S/17096.html#L290'>self</a>              290 sysdeps/htl/timer_routines.c thread_expire_timer (struct thread_node *self, struct timer_node *timer)</span>
<span class='curline'><a href='../S/17096.html#L292'>self</a>              292 sysdeps/htl/timer_routines.c   self-&gt;current_timer = timer; /* Lets timer_delete know timer is running. */</span>
<span class='curline'><a href='../S/17096.html#L320'>self</a>              320 sysdeps/htl/timer_routines.c       if (pthread_kill (self-&gt;captured, timer-&gt;event.sigev_signo) != 0)</span>
<span class='curline'><a href='../S/17096.html#L322'>self</a>              322 sysdeps/htl/timer_routines.c 	  if (pthread_kill (self-&gt;id, timer-&gt;event.sigev_signo) != 0)</span>
<span class='curline'><a href='../S/17096.html#L339'>self</a>              339 sysdeps/htl/timer_routines.c   self-&gt;current_timer = 0;</span>
<span class='curline'><a href='../S/17096.html#L341'>self</a>              341 sysdeps/htl/timer_routines.c   pthread_cond_broadcast (&amp;self-&gt;cond);</span>
<span class='curline'><a href='../S/17096.html#L353'>self</a>              353 sysdeps/htl/timer_routines.c   struct thread_node *self = arg;</span>
<span class='curline'><a href='../S/17096.html#L359'>self</a>              359 sysdeps/htl/timer_routines.c   pthread_cleanup_push (thread_cleanup, self);</span>
<span class='curline'><a href='../S/17096.html#L369'>self</a>              369 sysdeps/htl/timer_routines.c       first = list_first (&amp;self-&gt;timer_queue);</span>
<span class='curline'><a href='../S/17096.html#L370'>self</a>              370 sysdeps/htl/timer_routines.c       if (first != list_null (&amp;self-&gt;timer_queue))</span>
<span class='curline'><a href='../S/17096.html#L403'>self</a>              403 sysdeps/htl/timer_routines.c 		  __timer_thread_queue_timer (self, timer);</span>
<span class='curline'><a href='../S/17096.html#L406'>self</a>              406 sysdeps/htl/timer_routines.c 	      thread_expire_timer (self, timer);</span>
<span class='curline'><a href='../S/17096.html#L408'>self</a>              408 sysdeps/htl/timer_routines.c 	      first = list_first (&amp;self-&gt;timer_queue);</span>
<span class='curline'><a href='../S/17096.html#L409'>self</a>              409 sysdeps/htl/timer_routines.c 	      if (first == list_null (&amp;self-&gt;timer_queue))</span>
<span class='curline'><a href='../S/17096.html#L421'>self</a>              421 sysdeps/htl/timer_routines.c 	pthread_cond_timedwait (&amp;self-&gt;cond, &amp;__timer_mutex,</span>
<span class='curline'><a href='../S/17096.html#L424'>self</a>              424 sysdeps/htl/timer_routines.c 	pthread_cond_wait (&amp;self-&gt;cond, &amp;__timer_mutex);</span>
<span class='curline'><a href='../S/13297.html#L38'>self</a>               38 sysdeps/i386/nptl/tls.h   void *self;		/* Pointer to the thread descriptor.  */</span>
<span class='curline'><a href='../S/13297.html#L185'>self</a>              185 sysdeps/i386/nptl/tls.h      _head-&gt;self = _thrdescr;						      \</span>
<span class='curline'><a href='../S/13297.html#L233'>self</a>              233 sysdeps/i386/nptl/tls.h   (*(struct pthread *__seg_gs *) offsetof (struct pthread, header.self))</span>
<span class='curline'><a href='../S/13297.html#L238'>self</a>              238 sysdeps/i386/nptl/tls.h 	  : "i" (offsetof (struct pthread, header.self)));		      \</span>
<span class='curline'><a href='../S/12798.html#L19'>self</a>               19 sysdeps/ia64/machine-gmon.h #define _MCOUNT_DECL(from, self) \</span>
<span class='curline'><a href='../S/12798.html#L20'>self</a>               20 sysdeps/ia64/machine-gmon.h  void __mcount (u_long from, u_long self)</span>
<span class='curline'><a href='../S/13842.html#L83'>self</a>               83 sysdeps/mach/clock_gettime.c 	mach_port_t self = __mach_thread_self ();</span>
<span class='curline'><a href='../S/13842.html#L86'>self</a>               86 sysdeps/mach/clock_gettime.c 	err = __thread_info (self, THREAD_BASIC_INFO,</span>
<span class='curline'><a href='../S/13842.html#L88'>self</a>               88 sysdeps/mach/clock_gettime.c 	__mach_port_deallocate (__mach_task_self (), self);</span>
<span class='curline'><a href='../S/14291.html#L38'>self</a>               38 sysdeps/mach/htl/pt-thread-terminate.c   int self;</span>
<span class='curline'><a href='../S/14291.html#L57'>self</a>               57 sysdeps/mach/htl/pt-thread-terminate.c   self = self_ktid == kernel_thread;</span>
<span class='curline'><a href='../S/14291.html#L75'>self</a>               75 sysdeps/mach/htl/pt-thread-terminate.c   reply_port = self ? __mig_get_reply_port () : MACH_PORT_NULL;</span>
<span class='curline'><a href='../S/14207.html#L47'>self</a>               47 sysdeps/mach/hurd/htl/pt-hurd-cond-timedwait.c   struct __pthread *self = _pthread_self ();</span>
<span class='curline'><a href='../S/14207.html#L62'>self</a>               62 sysdeps/mach/hurd/htl/pt-hurd-cond-timedwait.c     unblock = self-&gt;prevp != NULL;</span>
<span class='curline'><a href='../S/14207.html#L64'>self</a>               64 sysdeps/mach/hurd/htl/pt-hurd-cond-timedwait.c       __pthread_dequeue (self);</span>
<span class='curline'><a href='../S/14207.html#L68'>self</a>               68 sysdeps/mach/hurd/htl/pt-hurd-cond-timedwait.c       __pthread_wakeup (self);</span>
<span class='curline'><a href='../S/14207.html#L93'>self</a>               93 sysdeps/mach/hurd/htl/pt-hurd-cond-timedwait.c       __pthread_enqueue (&amp;cond-&gt;__queue, self);</span>
<span class='curline'><a href='../S/14207.html#L120'>self</a>              120 sysdeps/mach/hurd/htl/pt-hurd-cond-timedwait.c 	err = __pthread_timedblock (self, abstime, clock_id);</span>
<span class='curline'><a href='../S/14207.html#L124'>self</a>              124 sysdeps/mach/hurd/htl/pt-hurd-cond-timedwait.c 	  __pthread_block (self);</span>
<span class='curline'><a href='../S/14207.html#L131'>self</a>              131 sysdeps/mach/hurd/htl/pt-hurd-cond-timedwait.c       if (self-&gt;prevp == NULL)</span>
<span class='curline'><a href='../S/14207.html#L142'>self</a>              142 sysdeps/mach/hurd/htl/pt-hurd-cond-timedwait.c 	  __pthread_dequeue (self);</span>
<span class='curline'><a href='../S/14207.html#L148'>self</a>              148 sysdeps/mach/hurd/htl/pt-hurd-cond-timedwait.c 	__pthread_block (self);</span>
<span class='curline'><a href='../S/14212.html#L29'>self</a>               29 sysdeps/mach/hurd/htl/pt-mutex-lock.c   struct __pthread *self;</span>
<span class='curline'><a href='../S/14212.html#L40'>self</a>               40 sysdeps/mach/hurd/htl/pt-mutex-lock.c       self = _pthread_self ();</span>
<span class='curline'><a href='../S/14212.html#L41'>self</a>               41 sysdeps/mach/hurd/htl/pt-mutex-lock.c       if (mtx_owned_p (mtxp, self, flags))</span>
<span class='curline'><a href='../S/14212.html#L51'>self</a>               51 sysdeps/mach/hurd/htl/pt-mutex-lock.c       mtx_set_owner (mtxp, self, flags);</span>
<span class='curline'><a href='../S/14212.html#L56'>self</a>               56 sysdeps/mach/hurd/htl/pt-mutex-lock.c       self = _pthread_self ();</span>
<span class='curline'><a href='../S/14212.html#L57'>self</a>               57 sysdeps/mach/hurd/htl/pt-mutex-lock.c       if (mtx_owned_p (mtxp, self, flags))</span>
<span class='curline'><a href='../S/14212.html#L61'>self</a>               61 sysdeps/mach/hurd/htl/pt-mutex-lock.c       mtx_set_owner (mtxp, self, flags);</span>
<span class='curline'><a href='../S/14212.html#L67'>self</a>               67 sysdeps/mach/hurd/htl/pt-mutex-lock.c       self = _pthread_self ();</span>
<span class='curline'><a href='../S/14212.html#L68'>self</a>               68 sysdeps/mach/hurd/htl/pt-mutex-lock.c       ROBUST_LOCK (self, mtxp, lll_robust_lock, flags);</span>
<span class='curline'><a href='../S/14204.html#L31'>self</a>               31 sysdeps/mach/hurd/htl/pt-mutex-timedlock.c   struct __pthread *self;</span>
<span class='curline'><a href='../S/14204.html#L41'>self</a>               41 sysdeps/mach/hurd/htl/pt-mutex-timedlock.c       self = _pthread_self ();</span>
<span class='curline'><a href='../S/14204.html#L42'>self</a>               42 sysdeps/mach/hurd/htl/pt-mutex-timedlock.c       if (mtx_owned_p (mtxp, self, flags))</span>
<span class='curline'><a href='../S/14204.html#L52'>self</a>               52 sysdeps/mach/hurd/htl/pt-mutex-timedlock.c 	  mtx_set_owner (mtxp, self, flags);</span>
<span class='curline'><a href='../S/14204.html#L59'>self</a>               59 sysdeps/mach/hurd/htl/pt-mutex-timedlock.c       self = _pthread_self ();</span>
<span class='curline'><a href='../S/14204.html#L60'>self</a>               60 sysdeps/mach/hurd/htl/pt-mutex-timedlock.c       if (mtx_owned_p (mtxp, self, flags))</span>
<span class='curline'><a href='../S/14204.html#L63'>self</a>               63 sysdeps/mach/hurd/htl/pt-mutex-timedlock.c 	mtx_set_owner (mtxp, self, flags);</span>
<span class='curline'><a href='../S/14204.html#L70'>self</a>               70 sysdeps/mach/hurd/htl/pt-mutex-timedlock.c       self = _pthread_self ();</span>
<span class='curline'><a href='../S/14204.html#L71'>self</a>               71 sysdeps/mach/hurd/htl/pt-mutex-timedlock.c       ROBUST_LOCK (self, mtxp, lll_robust_abstimed_lock, tsp, flags, clockid);</span>
<span class='curline'><a href='../S/14202.html#L30'>self</a>               30 sysdeps/mach/hurd/htl/pt-mutex-transfer-np.c   struct __pthread *self = _pthread_self ();</span>
<span class='curline'><a href='../S/14202.html#L35'>self</a>               35 sysdeps/mach/hurd/htl/pt-mutex-transfer-np.c   else if (pt == self)</span>
<span class='curline'><a href='../S/14202.html#L48'>self</a>               48 sysdeps/mach/hurd/htl/pt-mutex-transfer-np.c       if (!mtx_owned_p (mtxp, self, flags))</span>
<span class='curline'><a href='../S/14202.html#L61'>self</a>               61 sysdeps/mach/hurd/htl/pt-mutex-transfer-np.c       if (mtxp-&gt;__owner_id != self-&gt;thread</span>
<span class='curline'><a href='../S/14220.html#L29'>self</a>               29 sysdeps/mach/hurd/htl/pt-mutex-trylock.c   struct __pthread *self;</span>
<span class='curline'><a href='../S/14220.html#L41'>self</a>               41 sysdeps/mach/hurd/htl/pt-mutex-trylock.c       self = _pthread_self ();</span>
<span class='curline'><a href='../S/14220.html#L42'>self</a>               42 sysdeps/mach/hurd/htl/pt-mutex-trylock.c       if (mtx_owned_p (mtxp, self, mtxp-&gt;__flags))</span>
<span class='curline'><a href='../S/14220.html#L52'>self</a>               52 sysdeps/mach/hurd/htl/pt-mutex-trylock.c 	  mtx_set_owner (mtxp, self, mtxp-&gt;__flags);</span>
<span class='curline'><a href='../S/14220.html#L61'>self</a>               61 sysdeps/mach/hurd/htl/pt-mutex-trylock.c       self = _pthread_self ();</span>
<span class='curline'><a href='../S/14220.html#L63'>self</a>               63 sysdeps/mach/hurd/htl/pt-mutex-trylock.c 	mtx_set_owner (mtxp, self, mtxp-&gt;__flags);</span>
<span class='curline'><a href='../S/14220.html#L71'>self</a>               71 sysdeps/mach/hurd/htl/pt-mutex-trylock.c       self = _pthread_self ();</span>
<span class='curline'><a href='../S/14220.html#L72'>self</a>               72 sysdeps/mach/hurd/htl/pt-mutex-trylock.c       ROBUST_LOCK (self, mtxp, lll_robust_trylock);</span>
<span class='curline'><a href='../S/14193.html#L29'>self</a>               29 sysdeps/mach/hurd/htl/pt-mutex-unlock.c   struct __pthread *self;</span>
<span class='curline'><a href='../S/14193.html#L39'>self</a>               39 sysdeps/mach/hurd/htl/pt-mutex-unlock.c       self = _pthread_self ();</span>
<span class='curline'><a href='../S/14193.html#L40'>self</a>               40 sysdeps/mach/hurd/htl/pt-mutex-unlock.c       if (!mtx_owned_p (mtxp, self, flags))</span>
<span class='curline'><a href='../S/14193.html#L51'>self</a>               51 sysdeps/mach/hurd/htl/pt-mutex-unlock.c       self = _pthread_self ();</span>
<span class='curline'><a href='../S/14193.html#L52'>self</a>               52 sysdeps/mach/hurd/htl/pt-mutex-unlock.c       if (!mtx_owned_p (mtxp, self, flags))</span>
<span class='curline'><a href='../S/14193.html#L65'>self</a>               65 sysdeps/mach/hurd/htl/pt-mutex-unlock.c       self = _pthread_self ();</span>
<span class='curline'><a href='../S/14193.html#L68'>self</a>               68 sysdeps/mach/hurd/htl/pt-mutex-unlock.c       else if (mtxp-&gt;__owner_id != self-&gt;thread</span>
<span class='curline'><a href='../S/14192.html#L27'>self</a>               27 sysdeps/mach/hurd/htl/pt-mutex.h #define ROBUST_LOCK(self, mtxp, cb, ...)   \</span>
<span class='curline'><a href='../S/14192.html#L30'>self</a>               30 sysdeps/mach/hurd/htl/pt-mutex.h   else if (mtxp-&gt;__owner_id == self-&gt;thread   \</span>
<span class='curline'><a href='../S/14192.html#L52'>self</a>               52 sysdeps/mach/hurd/htl/pt-mutex.h           mtxp-&gt;__owner_id = self-&gt;thread;   \</span>
<span class='curline'><a href='../S/14033.html#L107'>self</a>              107 sysdeps/mach/hurd/i386/htl/pt-setup.c   tcb-&gt;self = thread-&gt;kernel_thread;</span>
<span class='curline'><a href='../S/14028.html#L35'>self</a>               35 sysdeps/mach/hurd/i386/tls.h   thread_t self;		/* This thread's control port.  */</span>
<span class='curline'><a href='../S/14028.html#L114'>self</a>              114 sysdeps/mach/hurd/i386/tls.h   thread_t self = __mach_thread_self ();</span>
<span class='curline'><a href='../S/14028.html#L125'>self</a>              125 sysdeps/mach/hurd/i386/tls.h   error_t err = __i386_set_gdt (self, &amp;sel, desc);</span>
<span class='curline'><a href='../S/14028.html#L130'>self</a>              130 sysdeps/mach/hurd/i386/tls.h       err = __i386_set_ldt (self, sel, &amp;desc, 1);</span>
<span class='curline'><a href='../S/14028.html#L149'>self</a>              149 sysdeps/mach/hurd/i386/tls.h   __mach_port_deallocate (__mach_task_self (), self);</span>
<span class='curline'><a href='../S/14028.html#L361'>self</a>              361 sysdeps/mach/hurd/i386/tls.h   tcb-&gt;self = child;</span>
<span class='curline'><a href='../S/17849.html#L31'>self</a>               31 sysdeps/nptl/_Fork.c       struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/17849.html#L44'>self</a>               44 sysdeps/nptl/_Fork.c       self-&gt;robust_prev = &amp;self-&gt;robust_head;</span>
<span class='curline'><a href='../S/17849.html#L46'>self</a>               46 sysdeps/nptl/_Fork.c       self-&gt;robust_head.list = &amp;self-&gt;robust_head;</span>
<span class='curline'><a href='../S/17849.html#L47'>self</a>               47 sysdeps/nptl/_Fork.c       INTERNAL_SYSCALL_CALL (set_robust_list, &amp;self-&gt;robust_head,</span>
<span class='curline'><a href='../S/17851.html#L30'>self</a>               30 sysdeps/nptl/dl-thread_gscope_wait.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/17851.html#L37'>self</a>               37 sysdeps/nptl/dl-thread_gscope_wait.c       if (t == self || t-&gt;header.gscope_flag == THREAD_GSCOPE_FLAG_UNUSED)</span>
<span class='curline'><a href='../S/17851.html#L60'>self</a>               60 sysdeps/nptl/dl-thread_gscope_wait.c       if (t == self || t-&gt;header.gscope_flag == THREAD_GSCOPE_FLAG_UNUSED)</span>
<span class='curline'><a href='../S/17843.html#L58'>self</a>               58 sysdeps/nptl/fork.h   struct pthread *self = (struct pthread *) THREAD_SELF;</span>
<span class='curline'><a href='../S/17843.html#L104'>self</a>              104 sysdeps/nptl/fork.h       if (curp != self)</span>
<span class='curline'><a href='../S/17843.html#L140'>self</a>              140 sysdeps/nptl/fork.h   list_del (&amp;self-&gt;list);</span>
<span class='curline'><a href='../S/17843.html#L146'>self</a>              146 sysdeps/nptl/fork.h   if (__glibc_unlikely (THREAD_GETMEM (self, user_stack)))</span>
<span class='curline'><a href='../S/17843.html#L147'>self</a>              147 sysdeps/nptl/fork.h     list_add (&amp;self-&gt;list, &amp;GL (dl_stack_user));</span>
<span class='curline'><a href='../S/17843.html#L149'>self</a>              149 sysdeps/nptl/fork.h     list_add (&amp;self-&gt;list, &amp;GL (dl_stack_used));</span>
<span class='curline'><a href='../S/17837.html#L92'>self</a>               92 sysdeps/nptl/libc-lock.h     void *self = THREAD_SELF;						      \</span>
<span class='curline'><a href='../S/17837.html#L93'>self</a>               93 sysdeps/nptl/libc-lock.h     if ((NAME).owner != self)						      \</span>
<span class='curline'><a href='../S/17837.html#L96'>self</a>               96 sysdeps/nptl/libc-lock.h 	(NAME).owner = self;						      \</span>
<span class='curline'><a href='../S/17837.html#L110'>self</a>              110 sysdeps/nptl/libc-lock.h     void *self = THREAD_SELF;						      \</span>
<span class='curline'><a href='../S/17837.html#L111'>self</a>              111 sysdeps/nptl/libc-lock.h     if ((NAME).owner != self)						      \</span>
<span class='curline'><a href='../S/17837.html#L115'>self</a>              115 sysdeps/nptl/libc-lock.h 	    (NAME).owner = self;					      \</span>
<span class='curline'><a href='../S/17845.html#L48'>self</a>               48 sysdeps/nptl/libc_start_call_main.h       struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/17845.html#L51'>self</a>               51 sysdeps/nptl/libc_start_call_main.h       unwind_buf.priv.data.prev = THREAD_GETMEM (self, cleanup_jmp_buf);</span>
<span class='curline'><a href='../S/17845.html#L52'>self</a>               52 sysdeps/nptl/libc_start_call_main.h       unwind_buf.priv.data.cleanup = THREAD_GETMEM (self, cleanup);</span>
<span class='curline'><a href='../S/17845.html#L55'>self</a>               55 sysdeps/nptl/libc_start_call_main.h       THREAD_SETMEM (self, cleanup_jmp_buf, &amp;unwind_buf);</span>
<span class='curline'><a href='../S/17823.html#L275'>self</a>              275 sysdeps/nptl/pthreadP.h   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/17823.html#L278'>self</a>              278 sysdeps/nptl/pthreadP.h   THREAD_ATOMIC_BIT_SET (self, cancelhandling, EXITING_BIT);</span>
<span class='curline'><a href='../S/17823.html#L281'>self</a>              281 sysdeps/nptl/pthreadP.h 		    THREAD_GETMEM (self, cleanup_jmp_buf));</span>
<span class='curline'><a href='../S/16231.html#L46'>self</a>               46 sysdeps/pthread/tst-eintr3.c   pthread_t self = pthread_self ();</span>
<span class='curline'><a href='../S/16231.html#L48'>self</a>               48 sysdeps/pthread/tst-eintr3.c   setup_eintr (SIGUSR1, &amp;self);</span>
<span class='curline'><a href='../S/16227.html#L33'>self</a>               33 sysdeps/pthread/tst-eintr4.c   pthread_t self = pthread_self ();</span>
<span class='curline'><a href='../S/16227.html#L35'>self</a>               35 sysdeps/pthread/tst-eintr4.c   setup_eintr (SIGUSR1, &amp;self);</span>
<span class='curline'><a href='../S/16368.html#L41'>self</a>               41 sysdeps/pthread/tst-signal6.c   pthread_t self = pthread_self ();</span>
<span class='curline'><a href='../S/16368.html#L45'>self</a>               45 sysdeps/pthread/tst-signal6.c     if (ti[i].s == self)</span>
<span class='curline'><a href='../S/16368.html#L47'>self</a>               47 sysdeps/pthread/tst-signal6.c 	if ((uintptr_t) ti[i].p &lt;= (uintptr_t) &amp;self</span>
<span class='curline'><a href='../S/16368.html#L48'>self</a>               48 sysdeps/pthread/tst-signal6.c 	    &amp;&amp; (uintptr_t) ti[i].p + 2 * MINSIGSTKSZ &gt; (uintptr_t) &amp;self)</span>
<span class='curline'><a href='../S/17807.html#L37'>self</a>               37 sysdeps/s390/nptl/tls.h   void *self;		/* Pointer to the thread descriptor.  */</span>
<span class='curline'><a href='../S/17807.html#L110'>self</a>              110 sysdeps/s390/nptl/tls.h      _head-&gt;self = _thrdescr;						      \</span>
<span class='curline'><a href='../S/16874.html#L37'>self</a>               37 sysdeps/sparc/nptl/tls.h   void *self;</span>
<span class='curline'><a href='../S/9856.html#L30'>self</a>               30 sysdeps/unix/sysv/linux/rseq-internal.h rseq_register_current_thread (struct pthread *self, bool do_rseq)</span>
<span class='curline'><a href='../S/9856.html#L34'>self</a>               34 sysdeps/unix/sysv/linux/rseq-internal.h       int ret = INTERNAL_SYSCALL_CALL (rseq, &amp;self-&gt;rseq_area,</span>
<span class='curline'><a href='../S/9856.html#L35'>self</a>               35 sysdeps/unix/sysv/linux/rseq-internal.h                                        sizeof (self-&gt;rseq_area),</span>
<span class='curline'><a href='../S/9856.html#L40'>self</a>               40 sysdeps/unix/sysv/linux/rseq-internal.h   THREAD_SETMEM (self, rseq_area.cpu_id, RSEQ_CPU_ID_REGISTRATION_FAILED);</span>
<span class='curline'><a href='../S/9856.html#L45'>self</a>               45 sysdeps/unix/sysv/linux/rseq-internal.h rseq_register_current_thread (struct pthread *self, bool do_rseq)</span>
<span class='curline'><a href='../S/9856.html#L47'>self</a>               47 sysdeps/unix/sysv/linux/rseq-internal.h   THREAD_SETMEM (self, rseq_area.cpu_id, RSEQ_CPU_ID_REGISTRATION_FAILED);</span>
<span class='curline'><a href='../S/11374.html#L28'>self</a>               28 sysdeps/unix/sysv/linux/safe-fatal.h   pid_t self = INTERNAL_SYSCALL_CALL (getpid);</span>
<span class='curline'><a href='../S/11374.html#L29'>self</a>               29 sysdeps/unix/sysv/linux/safe-fatal.h   INTERNAL_SYSCALL_CALL (kill, self, SIGKILL);</span>
<span class='curline'><a href='../S/10311.html#L69'>self</a>               69 sysdeps/unix/sysv/linux/tst-skeleton-thread-affinity.c   pthread_t self;</span>
<span class='curline'><a href='../S/10311.html#L137'>self</a>              137 sysdeps/unix/sysv/linux/tst-skeleton-thread-affinity.c       int ret = pthread_join (p-&gt;self, NULL);</span>
<span class='curline'><a href='../S/10311.html#L233'>self</a>              233 sysdeps/unix/sysv/linux/tst-skeleton-thread-affinity.c       ret = pthread_create (&amp;other_threads[cpu].self,</span>
<span class='curline'><a href='../S/11118.html#L84'>self</a>               84 sysdeps/unix/sysv/linux/x86_64/makecontext.c   struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/11118.html#L85'>self</a>               85 sysdeps/unix/sysv/linux/x86_64/makecontext.c   unsigned int feature_1 = THREAD_GETMEM (self, header.feature_1);</span>
<span class='curline'><a href='../S/7177.html#L231'>self</a>              231 sysdeps/x86/dl-cet.c 	  struct pthread *self = THREAD_SELF;</span>
<span class='curline'><a href='../S/7177.html#L232'>self</a>              232 sysdeps/x86/dl-cet.c 	  THREAD_SETMEM (self, header.feature_1, feature_1);</span>
<span class='curline'><a href='../S/15922.html#L47'>self</a>               47 sysdeps/x86_64/nptl/tls.h   void *self;		/* Pointer to the thread descriptor.  */</span>
<span class='curline'><a href='../S/15922.html#L149'>self</a>              149 sysdeps/x86_64/nptl/tls.h      _head-&gt;self = _thrdescr;						      \</span>
<span class='curline'><a href='../S/15922.html#L179'>self</a>              179 sysdeps/x86_64/nptl/tls.h   (*(struct pthread *__seg_fs *) offsetof (struct pthread, header.self))</span>
<span class='curline'><a href='../S/15922.html#L184'>self</a>              184 sysdeps/x86_64/nptl/tls.h 	  : "i" (offsetof (struct pthread, header.self)));	 	      \</span>
</pre>
</body>
</html>
