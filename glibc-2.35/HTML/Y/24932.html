<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>sem</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.12' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/6980.html#L48'>sem</a>                48 benchtests/bench-pthread-locks.c static sem_t sem;</span>
<span class='curline'><a href='../S/6980.html#L255'>sem</a>               255 benchtests/bench-pthread-locks.c   sem_init (&amp;sem, 0, 1);</span>
<span class='curline'><a href='../S/6980.html#L260'>sem</a>               260 benchtests/bench-pthread-locks.c       sem_post (&amp;sem);</span>
<span class='curline'><a href='../S/6980.html#L262'>sem</a>               262 benchtests/bench-pthread-locks.c       sem_wait (&amp;sem);</span>
<span class='curline'><a href='../S/6980.html#L275'>sem</a>               275 benchtests/bench-pthread-locks.c   sem_init (&amp;sem, 0, 0);</span>
<span class='curline'><a href='../S/6980.html#L280'>sem</a>               280 benchtests/bench-pthread-locks.c       sem_trywait (&amp;sem);</span>
<span class='curline'><a href='../S/18273.html#L23'>sem</a>                23 htl/semaphoreP.h static inline void __new_sem_open_init (struct new_sem *sem, unsigned value)</span>
<span class='curline'><a href='../S/18273.html#L26'>sem</a>                26 htl/semaphoreP.h   *sem = (struct new_sem) __SEMAPHORE_INITIALIZER (1, value);</span>
<span class='curline'><a href='../S/18602.html#L26'>sem</a>                26 nptl/sem_clockwait.c ___sem_clockwait64 (sem_t *sem, clockid_t clockid,</span>
<span class='curline'><a href='../S/18602.html#L43'>sem</a>                43 nptl/sem_clockwait.c   if (__new_sem_wait_fast ((struct new_sem *) sem, 0) == 0)</span>
<span class='curline'><a href='../S/18602.html#L46'>sem</a>                46 nptl/sem_clockwait.c     return __new_sem_wait_slow64 ((struct new_sem *) sem, clockid, abstime);</span>
<span class='curline'><a href='../S/18602.html#L56'>sem</a>                56 nptl/sem_clockwait.c ___sem_clockwait (sem_t *sem, clockid_t clockid, const struct timespec *abstime)</span>
<span class='curline'><a href='../S/18602.html#L60'>sem</a>                60 nptl/sem_clockwait.c   return __sem_clockwait64 (sem, clockid, &amp;ts64);</span>
<span class='curline'><a href='../S/18547.html#L24'>sem</a>                24 nptl/sem_destroy.c __new_sem_destroy (sem_t *sem)</span>
<span class='curline'><a href='../S/18533.html#L25'>sem</a>                25 nptl/sem_getvalue.c __new_sem_getvalue (sem_t *sem, int *sval)</span>
<span class='curline'><a href='../S/18533.html#L27'>sem</a>                27 nptl/sem_getvalue.c   struct new_sem *isem = (struct new_sem *) sem;</span>
<span class='curline'><a href='../S/18533.html#L52'>sem</a>                52 nptl/sem_getvalue.c __old_sem_getvalue (sem_t *sem, int *sval)</span>
<span class='curline'><a href='../S/18533.html#L54'>sem</a>                54 nptl/sem_getvalue.c   struct old_sem *isem = (struct old_sem *) sem;</span>
<span class='curline'><a href='../S/18485.html#L27'>sem</a>                27 nptl/sem_init.c __new_sem_init (sem_t *sem, int pshared, unsigned int value)</span>
<span class='curline'><a href='../S/18485.html#L46'>sem</a>                46 nptl/sem_init.c   struct new_sem *isem = (struct new_sem *) sem;</span>
<span class='curline'><a href='../S/18485.html#L72'>sem</a>                72 nptl/sem_init.c __old_sem_init (sem_t *sem, int pshared, unsigned int value)</span>
<span class='curline'><a href='../S/18485.html#L84'>sem</a>                84 nptl/sem_init.c   struct old_sem *isem = (struct old_sem *) sem;</span>
<span class='curline'><a href='../S/18695.html#L32'>sem</a>                32 nptl/sem_post.c __new_sem_post (sem_t *sem)</span>
<span class='curline'><a href='../S/18695.html#L34'>sem</a>                34 nptl/sem_post.c   struct new_sem *isem = (struct new_sem *) sem;</span>
<span class='curline'><a href='../S/18695.html#L87'>sem</a>                87 nptl/sem_post.c __old_sem_post (sem_t *sem)</span>
<span class='curline'><a href='../S/18695.html#L89'>sem</a>                89 nptl/sem_post.c   unsigned int *futex = (unsigned int *) sem;</span>
<span class='curline'><a href='../S/18479.html#L26'>sem</a>                26 nptl/sem_timedwait.c ___sem_timedwait64 (sem_t *sem, const struct __timespec64 *abstime)</span>
<span class='curline'><a href='../S/18479.html#L37'>sem</a>                37 nptl/sem_timedwait.c   if (__new_sem_wait_fast ((struct new_sem *) sem, 0) == 0)</span>
<span class='curline'><a href='../S/18479.html#L40'>sem</a>                40 nptl/sem_timedwait.c     return __new_sem_wait_slow64 ((struct new_sem *) sem,</span>
<span class='curline'><a href='../S/18479.html#L51'>sem</a>                51 nptl/sem_timedwait.c ___sem_timedwait (sem_t *sem, const struct timespec *abstime)</span>
<span class='curline'><a href='../S/18479.html#L55'>sem</a>                55 nptl/sem_timedwait.c   return __sem_timedwait64 (sem, &amp;ts64);</span>
<span class='curline'><a href='../S/18516.html#L24'>sem</a>                24 nptl/sem_wait.c __new_sem_wait (sem_t *sem)</span>
<span class='curline'><a href='../S/18516.html#L39'>sem</a>                39 nptl/sem_wait.c   if (__new_sem_wait_fast ((struct new_sem *) sem, 0) == 0)</span>
<span class='curline'><a href='../S/18516.html#L42'>sem</a>                42 nptl/sem_wait.c     return __new_sem_wait_slow64 ((struct new_sem *) sem,</span>
<span class='curline'><a href='../S/18516.html#L54'>sem</a>                54 nptl/sem_wait.c __old_sem_wait (sem_t *sem)</span>
<span class='curline'><a href='../S/18516.html#L56'>sem</a>                56 nptl/sem_wait.c   int *futex = (int *) sem;</span>
<span class='curline'><a href='../S/18516.html#L77'>sem</a>                77 nptl/sem_wait.c __new_sem_trywait (sem_t *sem)</span>
<span class='curline'><a href='../S/18516.html#L81'>sem</a>                81 nptl/sem_wait.c   if (__new_sem_wait_fast ((struct new_sem *) sem, 1) == 0)</span>
<span class='curline'><a href='../S/18516.html#L94'>sem</a>                94 nptl/sem_wait.c __old_sem_trywait (sem_t *sem)</span>
<span class='curline'><a href='../S/18516.html#L96'>sem</a>                96 nptl/sem_wait.c   int *futex = (int *) sem;</span>
<span class='curline'><a href='../S/18671.html#L82'>sem</a>                82 nptl/sem_waitcommon.c __sem_wait_32_finish (struct new_sem *sem);</span>
<span class='curline'><a href='../S/18671.html#L88'>sem</a>                88 nptl/sem_waitcommon.c   struct new_sem *sem = (struct new_sem *) arg;</span>
<span class='curline'><a href='../S/18671.html#L92'>sem</a>                92 nptl/sem_waitcommon.c   atomic_fetch_add_relaxed (&amp;sem-&gt;data, -((uint64_t) 1 &lt;&lt; SEM_NWAITERS_SHIFT));</span>
<span class='curline'><a href='../S/18671.html#L94'>sem</a>                94 nptl/sem_waitcommon.c   __sem_wait_32_finish (sem);</span>
<span class='curline'><a href='../S/18671.html#L105'>sem</a>               105 nptl/sem_waitcommon.c do_futex_wait (struct new_sem *sem, clockid_t clockid,</span>
<span class='curline'><a href='../S/18671.html#L112'>sem</a>               112 nptl/sem_waitcommon.c       (unsigned int *) &amp;sem-&gt;data + SEM_VALUE_OFFSET, 0,</span>
<span class='curline'><a href='../S/18671.html#L114'>sem</a>               114 nptl/sem_waitcommon.c       sem-&gt;private);</span>
<span class='curline'><a href='../S/18671.html#L116'>sem</a>               116 nptl/sem_waitcommon.c   err = __futex_abstimed_wait_cancelable64 (&amp;sem-&gt;value, SEM_NWAITERS_MASK,</span>
<span class='curline'><a href='../S/18671.html#L117'>sem</a>               117 nptl/sem_waitcommon.c 					    clockid, abstime, sem-&gt;private);</span>
<span class='curline'><a href='../S/18671.html#L125'>sem</a>               125 nptl/sem_waitcommon.c __new_sem_wait_fast (struct new_sem *sem, int definitive_result)</span>
<span class='curline'><a href='../S/18671.html#L136'>sem</a>               136 nptl/sem_waitcommon.c   uint64_t d = atomic_load_relaxed (&amp;sem-&gt;data);</span>
<span class='curline'><a href='../S/18671.html#L141'>sem</a>               141 nptl/sem_waitcommon.c       if (atomic_compare_exchange_weak_acquire (&amp;sem-&gt;data, &amp;d, d - 1))</span>
<span class='curline'><a href='../S/18671.html#L147'>sem</a>               147 nptl/sem_waitcommon.c   unsigned int v = atomic_load_relaxed (&amp;sem-&gt;value);</span>
<span class='curline'><a href='../S/18671.html#L152'>sem</a>               152 nptl/sem_waitcommon.c       if (atomic_compare_exchange_weak_acquire (&amp;sem-&gt;value,</span>
<span class='curline'><a href='../S/18671.html#L164'>sem</a>               164 nptl/sem_waitcommon.c __new_sem_wait_slow64 (struct new_sem *sem, clockid_t clockid,</span>
<span class='curline'><a href='../S/18671.html#L172'>sem</a>               172 nptl/sem_waitcommon.c   uint64_t d = atomic_fetch_add_relaxed (&amp;sem-&gt;data,</span>
<span class='curline'><a href='../S/18671.html#L175'>sem</a>               175 nptl/sem_waitcommon.c   pthread_cleanup_push (__sem_wait_cleanup, sem);</span>
<span class='curline'><a href='../S/18671.html#L183'>sem</a>               183 nptl/sem_waitcommon.c 	  err = do_futex_wait (sem, clockid, abstime);</span>
<span class='curline'><a href='../S/18671.html#L198'>sem</a>               198 nptl/sem_waitcommon.c 	      atomic_fetch_add_relaxed (&amp;sem-&gt;data,</span>
<span class='curline'><a href='../S/18671.html#L203'>sem</a>               203 nptl/sem_waitcommon.c 	  d = atomic_load_relaxed (&amp;sem-&gt;data);</span>
<span class='curline'><a href='../S/18671.html#L214'>sem</a>               214 nptl/sem_waitcommon.c 	  if (atomic_compare_exchange_weak_acquire (&amp;sem-&gt;data,</span>
<span class='curline'><a href='../S/18671.html#L254'>sem</a>               254 nptl/sem_waitcommon.c   atomic_fetch_add_acquire (&amp;sem-&gt;nwaiters, 1);</span>
<span class='curline'><a href='../S/18671.html#L256'>sem</a>               256 nptl/sem_waitcommon.c   pthread_cleanup_push (__sem_wait_cleanup, sem);</span>
<span class='curline'><a href='../S/18671.html#L262'>sem</a>               262 nptl/sem_waitcommon.c   v = atomic_load_relaxed (&amp;sem-&gt;value);</span>
<span class='curline'><a href='../S/18671.html#L278'>sem</a>               278 nptl/sem_waitcommon.c 	  while (!atomic_compare_exchange_weak_release (&amp;sem-&gt;value,</span>
<span class='curline'><a href='../S/18671.html#L284'>sem</a>               284 nptl/sem_waitcommon.c 	      err = do_futex_wait (sem, clockid, abstime);</span>
<span class='curline'><a href='../S/18671.html#L294'>sem</a>               294 nptl/sem_waitcommon.c 	      v = atomic_load_relaxed (&amp;sem-&gt;value);</span>
<span class='curline'><a href='../S/18671.html#L303'>sem</a>               303 nptl/sem_waitcommon.c   while (!atomic_compare_exchange_weak_acquire (&amp;sem-&gt;value,</span>
<span class='curline'><a href='../S/18671.html#L309'>sem</a>               309 nptl/sem_waitcommon.c   __sem_wait_32_finish (sem);</span>
<span class='curline'><a href='../S/18671.html#L318'>sem</a>               318 nptl/sem_waitcommon.c __sem_wait_32_finish (struct new_sem *sem)</span>
<span class='curline'><a href='../S/18671.html#L325'>sem</a>               325 nptl/sem_waitcommon.c   unsigned int wguess = atomic_load_relaxed (&amp;sem-&gt;nwaiters);</span>
<span class='curline'><a href='../S/18671.html#L333'>sem</a>               333 nptl/sem_waitcommon.c     atomic_fetch_and_acquire (&amp;sem-&gt;value, ~SEM_NWAITERS_MASK);</span>
<span class='curline'><a href='../S/18671.html#L339'>sem</a>               339 nptl/sem_waitcommon.c   unsigned int wfinal = atomic_fetch_add_release (&amp;sem-&gt;nwaiters, -1);</span>
<span class='curline'><a href='../S/18671.html#L346'>sem</a>               346 nptl/sem_waitcommon.c       unsigned int v = atomic_fetch_or_relaxed (&amp;sem-&gt;value,</span>
<span class='curline'><a href='../S/18671.html#L355'>sem</a>               355 nptl/sem_waitcommon.c 	futex_wake (&amp;sem-&gt;value, v, sem-&gt;private);</span>
<span class='curline'><a href='../S/18366.html#L25'>sem</a>                25 nptl/semaphoreP.h static inline void __new_sem_open_init (struct new_sem *sem, unsigned value)</span>
<span class='curline'><a href='../S/18366.html#L28'>sem</a>                28 nptl/semaphoreP.h   sem-&gt;data = value;</span>
<span class='curline'><a href='../S/18366.html#L30'>sem</a>                30 nptl/semaphoreP.h   sem-&gt;value = value &lt;&lt; SEM_VALUE_SHIFT;</span>
<span class='curline'><a href='../S/18366.html#L31'>sem</a>                31 nptl/semaphoreP.h   sem-&gt;nwaiters = 0;</span>
<span class='curline'><a href='../S/18366.html#L34'>sem</a>                34 nptl/semaphoreP.h   sem-&gt;pad = 0;</span>
<span class='curline'><a href='../S/18366.html#L37'>sem</a>                37 nptl/semaphoreP.h   sem-&gt;private = FUTEX_SHARED;</span>
<span class='curline'><a href='../S/18366.html#L41'>sem</a>                41 nptl/semaphoreP.h extern int __new_sem_init (sem_t *sem, int pshared, unsigned int value);</span>
<span class='curline'><a href='../S/18366.html#L42'>sem</a>                42 nptl/semaphoreP.h extern int __old_sem_init (sem_t *sem, int pshared, unsigned int value);</span>
<span class='curline'><a href='../S/18366.html#L43'>sem</a>                43 nptl/semaphoreP.h extern int __new_sem_destroy (sem_t *sem);</span>
<span class='curline'><a href='../S/18366.html#L44'>sem</a>                44 nptl/semaphoreP.h extern int __new_sem_post (sem_t *sem);</span>
<span class='curline'><a href='../S/18366.html#L45'>sem</a>                45 nptl/semaphoreP.h extern int __new_sem_wait (sem_t *sem);</span>
<span class='curline'><a href='../S/18366.html#L46'>sem</a>                46 nptl/semaphoreP.h extern int __old_sem_wait (sem_t *sem);</span>
<span class='curline'><a href='../S/18366.html#L47'>sem</a>                47 nptl/semaphoreP.h extern int __new_sem_trywait (sem_t *sem);</span>
<span class='curline'><a href='../S/18366.html#L48'>sem</a>                48 nptl/semaphoreP.h extern int __new_sem_getvalue (sem_t *sem, int *sval);</span>
<span class='curline'><a href='../S/18366.html#L55'>sem</a>                55 nptl/semaphoreP.h __sem_clockwait64 (sem_t *sem, clockid_t clockid,</span>
<span class='curline'><a href='../S/18366.html#L59'>sem</a>                59 nptl/semaphoreP.h __sem_timedwait64 (sem_t *sem, const struct __timespec64 *abstime);</span>
<span class='curline'><a href='../S/18634.html#L39'>sem</a>                39 nptl/tst-cancel7.c static sem_t *sem;</span>
<span class='curline'><a href='../S/18634.html#L59'>sem</a>                59 nptl/tst-cancel7.c   if (sem_post (sem) != 0)</span>
<span class='curline'><a href='../S/18634.html#L89'>sem</a>                89 nptl/tst-cancel7.c   sem = xmmap (NULL, sizeof (sem_t), PROT_READ | PROT_WRITE, MAP_SHARED,</span>
<span class='curline'><a href='../S/18634.html#L91'>sem</a>                91 nptl/tst-cancel7.c   TEST_VERIFY_EXIT (sem != SEM_FAILED);</span>
<span class='curline'><a href='../S/18634.html#L95'>sem</a>                95 nptl/tst-cancel7.c       TEST_VERIFY_EXIT (sem_init (sem, 1, 0) != -1);</span>
<span class='curline'><a href='../S/18634.html#L119'>sem</a>               119 nptl/tst-cancel7.c   if (sem_wait (sem) != 0)</span>
<span class='curline'><a href='../S/18390.html#L53'>sem</a>                53 nptl/tst-sem13.c int test_sem_timedwait (sem_t *sem, struct timespec *ts)</span>
<span class='curline'><a href='../S/18390.html#L55'>sem</a>                55 nptl/tst-sem13.c   return sem_timedwait (sem, ts);</span>
<span class='curline'><a href='../S/18390.html#L58'>sem</a>                58 nptl/tst-sem13.c int test_sem_clockwait_monotonic (sem_t *sem, struct timespec *ts)</span>
<span class='curline'><a href='../S/18390.html#L60'>sem</a>                60 nptl/tst-sem13.c   return sem_clockwait (sem, CLOCK_MONOTONIC, ts);</span>
<span class='curline'><a href='../S/18390.html#L63'>sem</a>                63 nptl/tst-sem13.c int test_sem_clockwait_realtime (sem_t *sem, struct timespec *ts)</span>
<span class='curline'><a href='../S/18390.html#L65'>sem</a>                65 nptl/tst-sem13.c   return sem_clockwait (sem, CLOCK_REALTIME, ts);</span>
<span class='curline'><a href='../S/18517.html#L40'>sem</a>                40 nptl/tst-signal3.c static sem_t sem;</span>
<span class='curline'><a href='../S/18517.html#L65'>sem</a>                65 nptl/tst-signal3.c   sem_post (&amp;sem);</span>
<span class='curline'><a href='../S/18517.html#L128'>sem</a>               128 nptl/tst-signal3.c   if (sem_init (&amp;sem, 0, INFLIGHT) != 0)</span>
<span class='curline'><a href='../S/18517.html#L179'>sem</a>               179 nptl/tst-signal3.c       if (TEMP_FAILURE_RETRY (sem_wait (&amp;sem)) != 0)</span>
<span class='curline'><a href='../S/1315.html#L28'>sem</a>                28 rt/tst-shm-cancel.c static sem_t sem;	/* Use to sync with thread start.  */</span>
<span class='curline'><a href='../S/1315.html#L49'>sem</a>                49 rt/tst-shm-cancel.c   if (sem_wait (&amp;sem) != 0)</span>
<span class='curline'><a href='../S/1315.html#L98'>sem</a>                98 rt/tst-shm-cancel.c   if (sem_init (&amp;sem, 0, 0))</span>
<span class='curline'><a href='../S/1315.html#L116'>sem</a>               116 rt/tst-shm-cancel.c   if (sem_post (&amp;sem) != 0)</span>
<span class='curline'><a href='../S/8487.html#L43'>sem</a>                43 sysdeps/gnu/bits/sem.h   struct sem *__sembase;		/* ptr to first semaphore in array */</span>
<span class='curline'><a href='../S/17113.html#L25'>sem</a>                25 sysdeps/htl/sem-destroy.c __sem_destroy (sem_t *sem)</span>
<span class='curline'><a href='../S/17113.html#L27'>sem</a>                27 sysdeps/htl/sem-destroy.c   struct new_sem *isem = (struct new_sem *) sem;</span>
<span class='curline'><a href='../S/17089.html#L23'>sem</a>                23 sysdeps/htl/sem-getvalue.c __sem_getvalue (sem_t *restrict sem, int *restrict value)</span>
<span class='curline'><a href='../S/17089.html#L25'>sem</a>                25 sysdeps/htl/sem-getvalue.c   struct new_sem *isem = (struct new_sem *) sem;</span>
<span class='curline'><a href='../S/17171.html#L25'>sem</a>                25 sysdeps/htl/sem-init.c __sem_init (sem_t *sem, int pshared, unsigned value)</span>
<span class='curline'><a href='../S/17171.html#L35'>sem</a>                35 sysdeps/htl/sem-init.c   struct new_sem *isem = (struct new_sem *) sem;</span>
<span class='curline'><a href='../S/17118.html#L27'>sem</a>                27 sysdeps/htl/sem-post.c __sem_post (sem_t *sem)</span>
<span class='curline'><a href='../S/17118.html#L29'>sem</a>                29 sysdeps/htl/sem-post.c   struct new_sem *isem = (struct new_sem *) sem;</span>
<span class='curline'><a href='../S/17167.html#L47'>sem</a>                47 sysdeps/htl/sem-timedwait.c __sem_timedwait_internal (sem_t *restrict sem,</span>
<span class='curline'><a href='../S/17167.html#L51'>sem</a>                51 sysdeps/htl/sem-timedwait.c   struct new_sem *isem = (struct new_sem *) sem;</span>
<span class='curline'><a href='../S/17167.html#L63'>sem</a>                63 sysdeps/htl/sem-timedwait.c   uint64_t d = atomic_fetch_add_relaxed (&amp;sem-&gt;data,</span>
<span class='curline'><a href='../S/17167.html#L75'>sem</a>                75 sysdeps/htl/sem-timedwait.c 		      ((unsigned int *) &amp;sem-&gt;data) + SEM_VALUE_OFFSET,</span>
<span class='curline'><a href='../S/17167.html#L79'>sem</a>                79 sysdeps/htl/sem-timedwait.c 		      ((unsigned int *) &amp;sem-&gt;data) + SEM_VALUE_OFFSET,</span>
<span class='curline'><a href='../S/17167.html#L95'>sem</a>                95 sysdeps/htl/sem-timedwait.c 	  d = atomic_load_relaxed (&amp;sem-&gt;data);</span>
<span class='curline'><a href='../S/17167.html#L100'>sem</a>               100 sysdeps/htl/sem-timedwait.c 	  if (atomic_compare_exchange_weak_acquire (&amp;sem-&gt;data,</span>
<span class='curline'><a href='../S/17167.html#L194'>sem</a>               194 sysdeps/htl/sem-timedwait.c __sem_clockwait (sem_t *sem, clockid_t clockid,</span>
<span class='curline'><a href='../S/17167.html#L197'>sem</a>               197 sysdeps/htl/sem-timedwait.c   return __sem_timedwait_internal (sem, clockid, timeout);</span>
<span class='curline'><a href='../S/17167.html#L202'>sem</a>               202 sysdeps/htl/sem-timedwait.c __sem_timedwait (sem_t *restrict sem, const struct timespec *restrict timeout)</span>
<span class='curline'><a href='../S/17167.html#L204'>sem</a>               204 sysdeps/htl/sem-timedwait.c   return __sem_timedwait_internal (sem, CLOCK_REALTIME, timeout);</span>
<span class='curline'><a href='../S/17180.html#L25'>sem</a>                25 sysdeps/htl/sem-trywait.c __sem_trywait (sem_t *sem)</span>
<span class='curline'><a href='../S/17180.html#L27'>sem</a>                27 sysdeps/htl/sem-trywait.c   struct new_sem *isem = (struct new_sem *) sem;</span>
<span class='curline'><a href='../S/17132.html#L22'>sem</a>                22 sysdeps/htl/sem-wait.c extern int __sem_timedwait_internal (sem_t *restrict sem,</span>
<span class='curline'><a href='../S/17132.html#L27'>sem</a>                27 sysdeps/htl/sem-wait.c __sem_wait (sem_t *sem)</span>
<span class='curline'><a href='../S/17132.html#L29'>sem</a>                29 sysdeps/htl/sem-wait.c   return __sem_timedwait_internal (sem, CLOCK_REALTIME, 0);</span>
<span class='curline'><a href='../S/16295.html#L23'>sem</a>                23 sysdeps/pthread/sem_close.c __sem_close (sem_t *sem)</span>
<span class='curline'><a href='../S/16295.html#L25'>sem</a>                25 sysdeps/pthread/sem_close.c   if (!__sem_remove_mapping (sem))</span>
<span class='curline'><a href='../S/16321.html#L111'>sem</a>               111 sysdeps/pthread/sem_open.c       } sem;</span>
<span class='curline'><a href='../S/16321.html#L113'>sem</a>               113 sysdeps/pthread/sem_open.c       __new_sem_open_init (&amp;sem.newsem, value);</span>
<span class='curline'><a href='../S/16321.html#L116'>sem</a>               116 sysdeps/pthread/sem_open.c       memset ((char *) &amp;sem.initsem + sizeof (struct new_sem), '\0',</span>
<span class='curline'><a href='../S/16321.html#L159'>sem</a>               159 sysdeps/pthread/sem_open.c       if (TEMP_FAILURE_RETRY (write (fd, &amp;sem.initsem, sizeof (sem_t)))</span>
<span class='curline'><a href='../S/16209.html#L30'>sem</a>                30 sysdeps/pthread/sem_routines.c   sem_t *sem;</span>
<span class='curline'><a href='../S/16209.html#L39'>sem</a>                39 sysdeps/pthread/sem_routines.c   sem_t *sem;</span>
<span class='curline'><a href='../S/16209.html#L96'>sem</a>                96 sysdeps/pthread/sem_routines.c 	  result = (*foundp)-&gt;sem;</span>
<span class='curline'><a href='../S/16209.html#L116'>sem</a>               116 sysdeps/pthread/sem_routines.c 	      newp-&gt;sem = existing;</span>
<span class='curline'><a href='../S/16209.html#L158'>sem</a>               158 sysdeps/pthread/sem_routines.c   if (nodep-&gt;sem == closure-&gt;the_sem)</span>
<span class='curline'><a href='../S/16209.html#L163'>sem</a>               163 sysdeps/pthread/sem_routines.c __sem_remove_mapping (sem_t *sem)</span>
<span class='curline'><a href='../S/16209.html#L173'>sem</a>               173 sysdeps/pthread/sem_routines.c     struct walk_closure closure = { .the_sem = sem, .rec = NULL };</span>
<span class='curline'><a href='../S/16209.html#L186'>sem</a>               186 sysdeps/pthread/sem_routines.c 	  if (__munmap (rec-&gt;sem, sizeof (sem_t)) == -1)</span>
<span class='curline'><a href='../S/16350.html#L25'>sem</a>                25 sysdeps/pthread/sem_routines.h bool __sem_remove_mapping (sem_t *sem) attribute_hidden;</span>
<span class='curline'><a href='../S/16383.html#L30'>sem</a>                30 sysdeps/pthread/tst-abstime.c static sem_t sem;</span>
<span class='curline'><a href='../S/16383.html#L58'>sem</a>                58 sysdeps/pthread/tst-abstime.c   sem_init (&amp;sem, 0, 0);</span>
<span class='curline'><a href='../S/16383.html#L59'>sem</a>                59 sysdeps/pthread/tst-abstime.c   TEST_COMPARE (sem_timedwait (&amp;sem, &amp;t), -1);</span>
<span class='curline'><a href='../S/16149.html#L29'>sem</a>                29 sysdeps/pthread/tst-cancel12.c static sem_t sem;</span>
<span class='curline'><a href='../S/16149.html#L58'>sem</a>                58 sysdeps/pthread/tst-cancel12.c   sem_wait (&amp;sem);</span>
<span class='curline'><a href='../S/16149.html#L79'>sem</a>                79 sysdeps/pthread/tst-cancel12.c   if (sem_init (&amp;sem, 0, 1) != 0)</span>
<span class='curline'><a href='../S/16311.html#L29'>sem</a>                29 sysdeps/pthread/tst-cancel13.c static sem_t sem;</span>
<span class='curline'><a href='../S/16311.html#L58'>sem</a>                58 sysdeps/pthread/tst-cancel13.c   sem_wait (&amp;sem);</span>
<span class='curline'><a href='../S/16311.html#L79'>sem</a>                79 sysdeps/pthread/tst-cancel13.c   if (sem_init (&amp;sem, 0, 0) != 0)</span>
<span class='curline'><a href='../S/16125.html#L30'>sem</a>                30 sysdeps/pthread/tst-cancel14.c static sem_t sem;</span>
<span class='curline'><a href='../S/16125.html#L68'>sem</a>                68 sysdeps/pthread/tst-cancel14.c   sem_timedwait (&amp;sem, &amp;ts);</span>
<span class='curline'><a href='../S/16125.html#L87'>sem</a>                87 sysdeps/pthread/tst-cancel14.c   if (sem_init (&amp;sem, 0, 1) != 0)</span>
<span class='curline'><a href='../S/16319.html#L30'>sem</a>                30 sysdeps/pthread/tst-cancel15.c static sem_t sem;</span>
<span class='curline'><a href='../S/16319.html#L71'>sem</a>                71 sysdeps/pthread/tst-cancel15.c   e = sem_timedwait (&amp;sem, &amp;ts);</span>
<span class='curline'><a href='../S/16319.html#L90'>sem</a>                90 sysdeps/pthread/tst-cancel15.c   if (sem_init (&amp;sem, 0, 0) != 0)</span>
<span class='curline'><a href='../S/16115.html#L33'>sem</a>                33 sysdeps/pthread/tst-kill6.c static sem_t sem;</span>
<span class='curline'><a href='../S/16115.html#L51'>sem</a>                51 sysdeps/pthread/tst-kill6.c   if (sem_post (&amp;sem) != 0)</span>
<span class='curline'><a href='../S/16115.html#L123'>sem</a>               123 sysdeps/pthread/tst-kill6.c   if (sem_init (&amp;sem, 0, 0) != 0)</span>
<span class='curline'><a href='../S/16115.html#L139'>sem</a>               139 sysdeps/pthread/tst-kill6.c       if (TEMP_FAILURE_RETRY (sem_wait (&amp;sem)) != 0)</span>
<span class='curline'><a href='../S/16203.html#L26'>sem</a>                26 sysdeps/pthread/tst-sem14.c sem_t sem;</span>
<span class='curline'><a href='../S/16203.html#L35'>sem</a>                35 sysdeps/pthread/tst-sem14.c       if (sem_wait (&amp;sem) != 0)</span>
<span class='curline'><a href='../S/16203.html#L41'>sem</a>                41 sysdeps/pthread/tst-sem14.c       if (sem_post (&amp;sem) != 0)</span>
<span class='curline'><a href='../S/16203.html#L53'>sem</a>                53 sysdeps/pthread/tst-sem14.c   if (sem_init (&amp;sem, 0, 0) != 0)</span>
<span class='curline'><a href='../S/16203.html#L69'>sem</a>                69 sysdeps/pthread/tst-sem14.c   if (sem_post (&amp;sem) != 0)</span>
<span class='curline'><a href='../S/16169.html#L28'>sem</a>                28 sysdeps/pthread/tst-sem16.c static sem_t sem;	/* Use to sync with thread start.  */</span>
<span class='curline'><a href='../S/16169.html#L42'>sem</a>                42 sysdeps/pthread/tst-sem16.c   if (sem_wait (&amp;sem) != 0)</span>
<span class='curline'><a href='../S/16169.html#L89'>sem</a>                89 sysdeps/pthread/tst-sem16.c   if (sem_init (&amp;sem, 0, 0))</span>
<span class='curline'><a href='../S/16169.html#L107'>sem</a>               107 sysdeps/pthread/tst-sem16.c   if (sem_post (&amp;sem) != 0)</span>
</pre>
</body>
</html>
