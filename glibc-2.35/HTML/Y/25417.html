<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>signals</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.12' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/2123.html#L35'>signals</a>            35 hurd/hurd/sigpreempt.h     sigset_t signals;		/* Signals preempted.  */</span>
<span class='curline'><a href='../S/2182.html#L154'>signals</a>           154 hurd/hurdfault.c   _hurdsig_fault_preemptor.signals = 0;</span>
<span class='curline'><a href='../S/2155.html#L31'>signals</a>            31 hurd/hurdfault.h   (_hurdsig_fault_preemptor.signals = (sigset),			\</span>
<span class='curline'><a href='../S/2155.html#L39'>signals</a>            39 hurd/hurdfault.h   (_hurdsig_fault_preemptor.signals = 0)</span>
<span class='curline'><a href='../S/2113.html#L28'>signals</a>            28 hurd/preempt-sig.c   _hurdsig_preempted_set |= preemptor-&gt;signals;</span>
<span class='curline'><a href='../S/2113.html#L46'>signals</a>            46 hurd/preempt-sig.c 	if ((preemptor-&gt;signals &amp; preempted) != preemptor-&gt;signals)</span>
<span class='curline'><a href='../S/2113.html#L53'>signals</a>            53 hurd/preempt-sig.c 	      preempted |= pp-&gt;signals;</span>
<span class='curline'><a href='../S/2113.html#L61'>signals</a>            61 hurd/preempt-sig.c 	preempted |= (*p)-&gt;signals;</span>
<span class='curline'><a href='../S/18653.html#L432'>signals</a>           432 nptl/pthread_cond_wait.c   unsigned int signals = atomic_load_acquire (cond-&gt;__data.__g_signals + g);</span>
<span class='curline'><a href='../S/18653.html#L449'>signals</a>           449 nptl/pthread_cond_wait.c 	  while (signals == 0 &amp;&amp; spin &gt; 0)</span>
<span class='curline'><a href='../S/18653.html#L459'>signals</a>           459 nptl/pthread_cond_wait.c 	      signals = atomic_load_acquire (cond-&gt;__data.__g_signals + g);</span>
<span class='curline'><a href='../S/18653.html#L465'>signals</a>           465 nptl/pthread_cond_wait.c 	  if (signals &amp; 1)</span>
<span class='curline'><a href='../S/18653.html#L469'>signals</a>           469 nptl/pthread_cond_wait.c 	  if (signals != 0)</span>
<span class='curline'><a href='../S/18653.html#L524'>signals</a>           524 nptl/pthread_cond_wait.c 	  signals = atomic_load_acquire (cond-&gt;__data.__g_signals + g);</span>
<span class='curline'><a href='../S/18653.html#L533'>signals</a>           533 nptl/pthread_cond_wait.c 						&amp;signals, signals - 2));</span>
<span class='curline'><a href='../S/18556.html#L32'>signals</a>            32 nptl/tst-pthread-attr-sigmask.c typedef bool signals[_NSIG];</span>
<span class='curline'><a href='../S/18556.html#L46'>signals</a>            46 nptl/tst-pthread-attr-sigmask.c check_sigmask (const char *context, signals expected_mask,</span>
<span class='curline'><a href='../S/18556.html#L63'>signals</a>            63 nptl/tst-pthread-attr-sigmask.c check_current_sigmask (const char *context, signals expected_mask)</span>
<span class='curline'><a href='../S/18556.html#L90'>signals</a>            90 nptl/tst-pthread-attr-sigmask.c check_posix_thread (pthread_attr_t *attr, signals expected_mask)</span>
<span class='curline'><a href='../S/18556.html#L99'>signals</a>            99 nptl/tst-pthread-attr-sigmask.c check_c11_thread (signals expected_mask)</span>
<span class='curline'><a href='../S/18556.html#L110'>signals</a>           110 nptl/tst-pthread-attr-sigmask.c   check_current_sigmask ("initial mask", (signals) { false, });</span>
<span class='curline'><a href='../S/18556.html#L111'>signals</a>           111 nptl/tst-pthread-attr-sigmask.c   check_posix_thread (NULL, (signals) { false, });</span>
<span class='curline'><a href='../S/18556.html#L112'>signals</a>           112 nptl/tst-pthread-attr-sigmask.c   check_c11_thread ((signals) { false, });</span>
<span class='curline'><a href='../S/18556.html#L118'>signals</a>           118 nptl/tst-pthread-attr-sigmask.c   check_current_sigmask ("SIGUSR1 masked", (signals) { [SIGUSR1] = true, });</span>
<span class='curline'><a href='../S/18556.html#L120'>signals</a>           120 nptl/tst-pthread-attr-sigmask.c   check_posix_thread (NULL, (signals) { [SIGUSR1] = true, });</span>
<span class='curline'><a href='../S/18556.html#L121'>signals</a>           121 nptl/tst-pthread-attr-sigmask.c   check_c11_thread ((signals) { [SIGUSR1] = true, });</span>
<span class='curline'><a href='../S/18556.html#L129'>signals</a>           129 nptl/tst-pthread-attr-sigmask.c   check_posix_thread (&amp;attr, (signals) { [SIGUSR1] = true, });</span>
<span class='curline'><a href='../S/18556.html#L138'>signals</a>           138 nptl/tst-pthread-attr-sigmask.c   check_sigmask ("pthread_attr_getsigmask_np", (signals) { [SIGUSR2] = true, },</span>
<span class='curline'><a href='../S/18556.html#L143'>signals</a>           143 nptl/tst-pthread-attr-sigmask.c   check_current_sigmask ("SIGUSR1 masked", (signals) { [SIGUSR1] = true, });</span>
<span class='curline'><a href='../S/18556.html#L144'>signals</a>           144 nptl/tst-pthread-attr-sigmask.c   check_posix_thread (&amp;attr, (signals) { [SIGUSR2] = true, });</span>
<span class='curline'><a href='../S/18556.html#L145'>signals</a>           145 nptl/tst-pthread-attr-sigmask.c   check_current_sigmask ("SIGUSR1 masked", (signals) { [SIGUSR1] = true, });</span>
<span class='curline'><a href='../S/18556.html#L148'>signals</a>           148 nptl/tst-pthread-attr-sigmask.c   check_c11_thread ((signals) { [SIGUSR1] = true, });</span>
<span class='curline'><a href='../S/18556.html#L153'>signals</a>           153 nptl/tst-pthread-attr-sigmask.c   check_posix_thread (&amp;attr, (signals) { [SIGUSR2] = true, });</span>
<span class='curline'><a href='../S/18556.html#L160'>signals</a>           160 nptl/tst-pthread-attr-sigmask.c   check_posix_thread (&amp;attr, (signals) { [SIGUSR1] = true, });</span>
<span class='curline'><a href='../S/18556.html#L173'>signals</a>           173 nptl/tst-pthread-attr-sigmask.c   check_sigmask ("default attribute", (signals) { [SIGHUP] = true, }, &amp;set);</span>
<span class='curline'><a href='../S/18556.html#L177'>signals</a>           177 nptl/tst-pthread-attr-sigmask.c   check_posix_thread (NULL, (signals) { [SIGHUP] = true, });</span>
<span class='curline'><a href='../S/18556.html#L178'>signals</a>           178 nptl/tst-pthread-attr-sigmask.c   check_c11_thread ((signals) { [SIGHUP] = true, });</span>
<span class='curline'><a href='../S/18556.html#L183'>signals</a>           183 nptl/tst-pthread-attr-sigmask.c   check_posix_thread (&amp;attr, (signals) { [SIGUSR1] = true, });</span>
<span class='curline'><a href='../S/18556.html#L190'>signals</a>           190 nptl/tst-pthread-attr-sigmask.c   check_posix_thread (&amp;attr, (signals) { [SIGUSR2] = true, });</span>
<span class='curline'><a href='../S/18556.html#L198'>signals</a>           198 nptl/tst-pthread-attr-sigmask.c   check_posix_thread (NULL, (signals) { [SIGUSR1] = true, });</span>
<span class='curline'><a href='../S/18556.html#L199'>signals</a>           199 nptl/tst-pthread-attr-sigmask.c   check_c11_thread ((signals) { [SIGUSR1] = true, });</span>
<span class='curline'><a href='../S/12820.html#L24'>signals</a>            24 sysdeps/hurd/include/hurd/sigpreempt.h   (((preemptor)-&gt;signals &amp; __sigmask (signo)) \</span>
<span class='curline'><a href='../S/13912.html#L207'>signals</a>           207 sysdeps/mach/hurd/setitimer.c 	  _hurdsig_preempted_set |= preemptor.signals;</span>
<span class='curline'><a href='../S/13890.html#L99'>signals</a>            99 sysdeps/mach/hurd/sigwait.c       preemptor.signals = mask;</span>
</pre>
</body>
</html>
