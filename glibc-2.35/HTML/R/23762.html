<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>req</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.12' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/1458.html#L35'>req</a>                35 dlfcn/tst-dlinfo.c #define TRY(req, arg)							      \</span>
<span class='curline'><a href='../S/1458.html#L36'>req</a>                36 dlfcn/tst-dlinfo.c   if (dlinfo (handle, req, arg) != 0)					      \</span>
<span class='curline'><a href='../S/1458.html#L38'>req</a>                38 dlfcn/tst-dlinfo.c       printf ("dlinfo failed for %s: %s\n", #req, dlerror ());		      \</span>
<span class='curline'><a href='../S/18028.html#L324'>req</a>               324 include/time.h                                      int flags, const struct __timespec64 *req,</span>
<span class='curline'><a href='../S/2268.html#L621'>req</a>               621 locale/programs/locarchive.c 	      struct timespec req;</span>
<span class='curline'><a href='../S/2268.html#L624'>req</a>               624 locale/programs/locarchive.c 	      req.tv_sec = 0;</span>
<span class='curline'><a href='../S/2268.html#L625'>req</a>               625 locale/programs/locarchive.c 	      req.tv_nsec = 1000000 * (random () % 500 + 1);</span>
<span class='curline'><a href='../S/2268.html#L626'>req</a>               626 locale/programs/locarchive.c 	      (void) nanosleep (&amp;req, NULL);</span>
<span class='curline'><a href='../S/1868.html#L1331'>req</a>              1331 malloc/malloc.c #define request2size(req)                                         \</span>
<span class='curline'><a href='../S/1868.html#L1332'>req</a>              1332 malloc/malloc.c   (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span>
<span class='curline'><a href='../S/1868.html#L1334'>req</a>              1334 malloc/malloc.c    ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span>
<span class='curline'><a href='../S/1868.html#L1341'>req</a>              1341 malloc/malloc.c checked_request2size (size_t req, size_t *sz) __nonnull (1)</span>
<span class='curline'><a href='../S/1868.html#L1343'>req</a>              1343 malloc/malloc.c   if (__glibc_unlikely (req &gt; PTRDIFF_MAX))</span>
<span class='curline'><a href='../S/1868.html#L1358'>req</a>              1358 malloc/malloc.c       req = (req + (__MTAG_GRANULE_SIZE - 1)) &amp;</span>
<span class='curline'><a href='../S/1868.html#L1362'>req</a>              1362 malloc/malloc.c   *sz = request2size (req);</span>
<span class='curline'><a href='../S/2307.html#L31'>req</a>                31 nis/nis_add.c    struct ns_request req;</span>
<span class='curline'><a href='../S/2307.html#L40'>req</a>                40 nis/nis_add.c    req.ns_name = (char *)name;</span>
<span class='curline'><a href='../S/2307.html#L55'>req</a>                55 nis/nis_add.c    req.ns_object.ns_object_val = nis_clone_object (&amp;obj, NULL);</span>
<span class='curline'><a href='../S/2307.html#L56'>req</a>                56 nis/nis_add.c    if (req.ns_object.ns_object_val == NULL)</span>
<span class='curline'><a href='../S/2307.html#L61'>req</a>                61 nis/nis_add.c    req.ns_object.ns_object_len = 1;</span>
<span class='curline'><a href='../S/2307.html#L63'>req</a>                63 nis/nis_add.c    status = __do_niscall (req.ns_object.ns_object_val[0].zo_domain,</span>
<span class='curline'><a href='../S/2307.html#L65'>req</a>                65 nis/nis_add.c  			 (caddr_t) &amp;req, (xdrproc_t) _xdr_nis_result,</span>
<span class='curline'><a href='../S/2307.html#L70'>req</a>                70 nis/nis_add.c    nis_destroy_object (req.ns_object.ns_object_val);</span>
<span class='curline'><a href='../S/2350.html#L298'>req</a>               298 nis/nis_call.c __do_niscall3 (dir_binding *dbp, u_long prog, xdrproc_t xargs, caddr_t req,</span>
<span class='curline'><a href='../S/2350.html#L310'>req</a>               310 nis/nis_call.c       result = clnt_call (dbp-&gt;clnt, prog, xargs, req, xres, resp, RPCTIMEOUT);</span>
<span class='curline'><a href='../S/2350.html#L383'>req</a>               383 nis/nis_call.c 	       xdrproc_t xargs, caddr_t req, xdrproc_t xres, caddr_t resp,</span>
<span class='curline'><a href='../S/2350.html#L400'>req</a>               400 nis/nis_call.c   status = __do_niscall3 (&amp;dbp, prog, xargs, req, xres, resp, flags, cb);</span>
<span class='curline'><a href='../S/2350.html#L825'>req</a>               825 nis/nis_call.c 	      caddr_t req, xdrproc_t xres, caddr_t resp, unsigned int flags,</span>
<span class='curline'><a href='../S/2350.html#L835'>req</a>               835 nis/nis_call.c       retcode = __do_niscall3 (&amp;bptr, prog, xargs, req, xres, resp, flags, cb);</span>
<span class='curline'><a href='../S/2328.html#L56'>req</a>                56 nis/nis_intern.h 				u_long prog, xdrproc_t xargs, caddr_t req,</span>
<span class='curline'><a href='../S/2328.html#L60'>req</a>                60 nis/nis_intern.h 			       xdrproc_t xargs, caddr_t req,</span>
<span class='curline'><a href='../S/2328.html#L64'>req</a>                64 nis/nis_intern.h 				xdrproc_t xargs, caddr_t req,</span>
<span class='curline'><a href='../S/2352.html#L30'>req</a>                30 nis/nis_lookup.c   struct ns_request req;</span>
<span class='curline'><a href='../S/2352.html#L57'>req</a>                57 nis/nis_lookup.c   req.ns_name = names[0];</span>
<span class='curline'><a href='../S/2352.html#L62'>req</a>                62 nis/nis_lookup.c       req.ns_object.ns_object_len = 0;</span>
<span class='curline'><a href='../S/2352.html#L63'>req</a>                63 nis/nis_lookup.c       req.ns_object.ns_object_val = NULL;</span>
<span class='curline'><a href='../S/2352.html#L65'>req</a>                65 nis/nis_lookup.c       status = __prepare_niscall (req.ns_name, &amp;dir, &amp;bptr, flags);</span>
<span class='curline'><a href='../S/2352.html#L80'>req</a>                80 nis/nis_lookup.c 			      (caddr_t) &amp;req, (xdrproc_t) _xdr_nis_result,</span>
<span class='curline'><a href='../S/2352.html#L101'>req</a>               101 nis/nis_lookup.c 			req.ns_name =</span>
<span class='curline'><a href='../S/2352.html#L128'>req</a>               128 nis/nis_lookup.c 			if (__nisfind_server (req.ns_name, 1, &amp;dir, &amp;bptr,</span>
<span class='curline'><a href='../S/2352.html#L137'>req</a>               137 nis/nis_lookup.c 			  const char *ndomain = __nis_domain_of (req.ns_name);</span>
<span class='curline'><a href='../S/2352.html#L138'>req</a>               138 nis/nis_lookup.c 			  req.ns_name = strdupa (ndomain);</span>
<span class='curline'><a href='../S/2352.html#L139'>req</a>               139 nis/nis_lookup.c 			  if (strcmp (req.ns_name, ".") == 0)</span>
<span class='curline'><a href='../S/2352.html#L148'>req</a>               148 nis/nis_lookup.c 			  status = __prepare_niscall (req.ns_name, &amp;dir,</span>
<span class='curline'><a href='../S/2352.html#L196'>req</a>               196 nis/nis_lookup.c 	      free (req.ns_name);</span>
<span class='curline'><a href='../S/2352.html#L207'>req</a>               207 nis/nis_lookup.c 	  req.ns_name = names[name_nr];</span>
<span class='curline'><a href='../S/2337.html#L31'>req</a>                31 nis/nis_modify.c   struct ns_request req;</span>
<span class='curline'><a href='../S/2337.html#L40'>req</a>                40 nis/nis_modify.c   req.ns_name = (char *) name;</span>
<span class='curline'><a href='../S/2337.html#L55'>req</a>                55 nis/nis_modify.c   req.ns_object.ns_object_val = nis_clone_object (&amp;obj, NULL);</span>
<span class='curline'><a href='../S/2337.html#L56'>req</a>                56 nis/nis_modify.c   if (req.ns_object.ns_object_val == NULL)</span>
<span class='curline'><a href='../S/2337.html#L61'>req</a>                61 nis/nis_modify.c   req.ns_object.ns_object_len = 1;</span>
<span class='curline'><a href='../S/2337.html#L64'>req</a>                64 nis/nis_modify.c 			 (caddr_t) &amp; req, (xdrproc_t) _xdr_nis_result,</span>
<span class='curline'><a href='../S/2337.html#L70'>req</a>                70 nis/nis_modify.c   nis_destroy_object (req.ns_object.ns_object_val);</span>
<span class='curline'><a href='../S/2345.html#L29'>req</a>                29 nis/nis_remove.c   struct ns_request req;</span>
<span class='curline'><a href='../S/2345.html#L35'>req</a>                35 nis/nis_remove.c   req.ns_name = (char *)name;</span>
<span class='curline'><a href='../S/2345.html#L39'>req</a>                39 nis/nis_remove.c       req.ns_object.ns_object_len = 1;</span>
<span class='curline'><a href='../S/2345.html#L40'>req</a>                40 nis/nis_remove.c       req.ns_object.ns_object_val = nis_clone_object (obj, NULL);</span>
<span class='curline'><a href='../S/2345.html#L44'>req</a>                44 nis/nis_remove.c       req.ns_object.ns_object_len = 0;</span>
<span class='curline'><a href='../S/2345.html#L45'>req</a>                45 nis/nis_remove.c       req.ns_object.ns_object_val = NULL;</span>
<span class='curline'><a href='../S/2345.html#L49'>req</a>                49 nis/nis_remove.c 			      (caddr_t) &amp;req, (xdrproc_t) _xdr_nis_result,</span>
<span class='curline'><a href='../S/2345.html#L54'>req</a>                54 nis/nis_remove.c   nis_destroy_object (req.ns_object.ns_object_val);</span>
<span class='curline'><a href='../S/2324.html#L139'>req</a>               139 nis/nis_table.c   struct ns_request req;</span>
<span class='curline'><a href='../S/2324.html#L143'>req</a>               143 nis/nis_table.c   req.ns_name = name;</span>
<span class='curline'><a href='../S/2324.html#L144'>req</a>               144 nis/nis_table.c   req.ns_object.ns_object_len = 0;</span>
<span class='curline'><a href='../S/2324.html#L145'>req</a>               145 nis/nis_table.c   req.ns_object.ns_object_val = NULL;</span>
<span class='curline'><a href='../S/2324.html#L148'>req</a>               148 nis/nis_table.c 		      (caddr_t) &amp;req, (xdrproc_t) _xdr_nis_result,</span>
<span class='curline'><a href='../S/2356.html#L274'>req</a>               274 nis/ypclnt.c   	       caddr_t req, xdrproc_t xres, caddr_t resp, dom_binding **ydb,</span>
<span class='curline'><a href='../S/2356.html#L280'>req</a>               280 nis/ypclnt.c   		      xargs, req, xres, resp, RPCTIMEOUT);</span>
<span class='curline'><a href='../S/2356.html#L297'>req</a>               297 nis/ypclnt.c   	   caddr_t req, xdrproc_t xres, caddr_t resp)</span>
<span class='curline'><a href='../S/2356.html#L314'>req</a>               314 nis/ypclnt.c   	      status = __ypclnt_call (domain, prog, xargs, req, xres,</span>
<span class='curline'><a href='../S/2356.html#L338'>req</a>               338 nis/ypclnt.c         status = __ypclnt_call (domain, prog, xargs, req, xres,</span>
<span class='curline'><a href='../S/2356.html#L351'>req</a>               351 nis/ypclnt.c   	  status = __ypclnt_call (domain, prog, xargs, req, xres,</span>
<span class='curline'><a href='../S/2356.html#L368'>req</a>               368 nis/ypclnt.c   	      caddr_t req, xdrproc_t xres, caddr_t resp)</span>
<span class='curline'><a href='../S/2356.html#L370'>req</a>               370 nis/ypclnt.c     int status = do_ypcall (domain, prog, xargs, req, xres, resp);</span>
<span class='curline'><a href='../S/2356.html#L442'>req</a>               442 nis/ypclnt.c     ypreq_key req;</span>
<span class='curline'><a href='../S/2356.html#L451'>req</a>               451 nis/ypclnt.c     req.domain = (char *) indomain;</span>
<span class='curline'><a href='../S/2356.html#L452'>req</a>               452 nis/ypclnt.c     req.map = (char *) inmap;</span>
<span class='curline'><a href='../S/2356.html#L453'>req</a>               453 nis/ypclnt.c     req.key.keydat_val = (char *) inkey;</span>
<span class='curline'><a href='../S/2356.html#L454'>req</a>               454 nis/ypclnt.c     req.key.keydat_len = inkeylen;</span>
<span class='curline'><a href='../S/2356.html#L461'>req</a>               461 nis/ypclnt.c   			 (caddr_t) &amp;req, (xdrproc_t) xdr_ypresp_val,</span>
<span class='curline'><a href='../S/2356.html#L487'>req</a>               487 nis/ypclnt.c     ypreq_nokey req;</span>
<span class='curline'><a href='../S/2356.html#L495'>req</a>               495 nis/ypclnt.c     req.domain = (char *) indomain;</span>
<span class='curline'><a href='../S/2356.html#L496'>req</a>               496 nis/ypclnt.c     req.map = (char *) inmap;</span>
<span class='curline'><a href='../S/2356.html#L503'>req</a>               503 nis/ypclnt.c   		      (caddr_t) &amp;req, (xdrproc_t) xdr_ypresp_key_val,</span>
<span class='curline'><a href='../S/2356.html#L543'>req</a>               543 nis/ypclnt.c     ypreq_key req;</span>
<span class='curline'><a href='../S/2356.html#L552'>req</a>               552 nis/ypclnt.c     req.domain = (char *) indomain;</span>
<span class='curline'><a href='../S/2356.html#L553'>req</a>               553 nis/ypclnt.c     req.map = (char *) inmap;</span>
<span class='curline'><a href='../S/2356.html#L554'>req</a>               554 nis/ypclnt.c     req.key.keydat_val = (char *) inkey;</span>
<span class='curline'><a href='../S/2356.html#L555'>req</a>               555 nis/ypclnt.c     req.key.keydat_len = inkeylen;</span>
<span class='curline'><a href='../S/2356.html#L562'>req</a>               562 nis/ypclnt.c   			 (caddr_t) &amp;req, (xdrproc_t) xdr_ypresp_key_val,</span>
<span class='curline'><a href='../S/2356.html#L598'>req</a>               598 nis/ypclnt.c     ypreq_nokey req;</span>
<span class='curline'><a href='../S/2356.html#L606'>req</a>               606 nis/ypclnt.c     req.domain = (char *) indomain;</span>
<span class='curline'><a href='../S/2356.html#L607'>req</a>               607 nis/ypclnt.c     req.map = (char *) inmap;</span>
<span class='curline'><a href='../S/2356.html#L612'>req</a>               612 nis/ypclnt.c   			 (caddr_t) &amp;req, (xdrproc_t) xdr_ypresp_master,</span>
<span class='curline'><a href='../S/2356.html#L628'>req</a>               628 nis/ypclnt.c     struct ypreq_nokey req;</span>
<span class='curline'><a href='../S/2356.html#L636'>req</a>               636 nis/ypclnt.c     req.domain = (char *) indomain;</span>
<span class='curline'><a href='../S/2356.html#L637'>req</a>               637 nis/ypclnt.c     req.map = (char *) inmap;</span>
<span class='curline'><a href='../S/2356.html#L642'>req</a>               642 nis/ypclnt.c   			 (caddr_t) &amp;req, (xdrproc_t) xdr_ypresp_order,</span>
<span class='curline'><a href='../S/2356.html#L724'>req</a>               724 nis/ypclnt.c     struct ypreq_nokey req;</span>
<span class='curline'><a href='../S/2356.html#L763'>req</a>               763 nis/ypclnt.c         req.domain = (char *) indomain;</span>
<span class='curline'><a href='../S/2356.html#L764'>req</a>               764 nis/ypclnt.c         req.map = (char *) inmap;</span>
<span class='curline'><a href='../S/2356.html#L770'>req</a>               770 nis/ypclnt.c   			  (caddr_t) &amp;req, (xdrproc_t) __xdr_ypresp_all,</span>
<span class='curline'><a href='../S/1661.html#L47'>req</a>                47 nscd/aicache.c addhstaiX (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1661.html#L161'>req</a>               161 nscd/aicache.c 							+ req-&gt;key_len, 1);</span>
<span class='curline'><a href='../S/1661.html#L168'>req</a>               168 nscd/aicache.c 	      dataset = (struct dataset *) alloca (total + req-&gt;key_len);</span>
<span class='curline'><a href='../S/1661.html#L333'>req</a>               333 nscd/aicache.c 							+ req-&gt;key_len, 1);</span>
<span class='curline'><a href='../S/1661.html#L340'>req</a>               340 nscd/aicache.c 	      dataset = (struct dataset *) alloca (total + req-&gt;key_len);</span>
<span class='curline'><a href='../S/1661.html#L362'>req</a>               362 nscd/aicache.c       timeout = datahead_init_pos (&amp;dataset-&gt;head, total + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1661.html#L378'>req</a>               378 nscd/aicache.c       key_copy = memcpy (cp, key, req-&gt;key_len);</span>
<span class='curline'><a href='../S/1661.html#L388'>req</a>               388 nscd/aicache.c 	  if (total + req-&gt;key_len == dh-&gt;allocsize</span>
<span class='curline'><a href='../S/1661.html#L406'>req</a>               406 nscd/aicache.c 		= (struct dataset *) mempool_alloc (db, total + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1661.html#L413'>req</a>               413 nscd/aicache.c 		  dataset = memcpy (newp, dataset, total + req-&gt;key_len);</span>
<span class='curline'><a href='../S/1661.html#L475'>req</a>               475 nscd/aicache.c 					      + req-&gt;key_len), 1)) != NULL)</span>
<span class='curline'><a href='../S/1661.html#L478'>req</a>               478 nscd/aicache.c 				       sizeof (struct dataset) + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1661.html#L485'>req</a>               485 nscd/aicache.c 	  key_copy = memcpy (dataset-&gt;strdata, key, req-&gt;key_len);</span>
<span class='curline'><a href='../S/1661.html#L500'>req</a>               500 nscd/aicache.c 		 ((uintptr_t) dataset &amp; pagesize_m1) + total + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1661.html#L504'>req</a>               504 nscd/aicache.c       (void) cache_add (req-&gt;type, key_copy, req-&gt;key_len, &amp;dataset-&gt;head,</span>
<span class='curline'><a href='../S/1661.html#L523'>req</a>               523 nscd/aicache.c addhstai (struct database_dyn *db, int fd, request_header *req, void *key,</span>
<span class='curline'><a href='../S/1661.html#L526'>req</a>               526 nscd/aicache.c   addhstaiX (db, fd, req, key, uid, NULL, NULL);</span>
<span class='curline'><a href='../S/1661.html#L533'>req</a>               533 nscd/aicache.c   request_header req =</span>
<span class='curline'><a href='../S/1661.html#L539'>req</a>               539 nscd/aicache.c   return addhstaiX (db, -1, &amp;req, db-&gt;data + he-&gt;key, he-&gt;owner, he, dh);</span>
<span class='curline'><a href='../S/1660.html#L1045'>req</a>              1045 nscd/connections.c handle_request (int fd, request_header *req, void *key, uid_t uid, pid_t pid)</span>
<span class='curline'><a href='../S/1660.html#L1047'>req</a>              1047 nscd/connections.c   if (__builtin_expect (req-&gt;version, NSCD_VERSION) != NSCD_VERSION)</span>
<span class='curline'><a href='../S/1660.html#L1052'>req</a>              1052 nscd/connections.c 		 req-&gt;version, NSCD_VERSION);</span>
<span class='curline'><a href='../S/1660.html#L1057'>req</a>              1057 nscd/connections.c   if (selinux_enabled &amp;&amp; nscd_request_avc_has_perm (fd, req-&gt;type) != 0)</span>
<span class='curline'><a href='../S/1660.html#L1089'>req</a>              1089 nscd/connections.c   struct database_dyn *db = reqinfo[req-&gt;type].db;</span>
<span class='curline'><a href='../S/1660.html#L1092'>req</a>              1092 nscd/connections.c   if (__builtin_expect (reqinfo[req-&gt;type].data_request, true))</span>
<span class='curline'><a href='../S/1660.html#L1096'>req</a>              1096 nscd/connections.c 	  if (req-&gt;type == GETHOSTBYADDR || req-&gt;type == GETHOSTBYADDRv6)</span>
<span class='curline'><a href='../S/1660.html#L1100'>req</a>              1100 nscd/connections.c 	      dbg_log ("\t%s (%s)", serv2str[req-&gt;type],</span>
<span class='curline'><a href='../S/1660.html#L1101'>req</a>              1101 nscd/connections.c 		       inet_ntop (req-&gt;type == GETHOSTBYADDR</span>
<span class='curline'><a href='../S/1660.html#L1106'>req</a>              1106 nscd/connections.c 	    dbg_log ("\t%s (%s)", serv2str[req-&gt;type], (char *) key);</span>
<span class='curline'><a href='../S/1660.html#L1137'>req</a>              1137 nscd/connections.c       cached = (struct datahead *) cache_search (req-&gt;type, key, req-&gt;key_len,</span>
<span class='curline'><a href='../S/1660.html#L1160'>req</a>              1160 nscd/connections.c       if (req-&gt;type == INVALIDATE)</span>
<span class='curline'><a href='../S/1660.html#L1161'>req</a>              1161 nscd/connections.c 	dbg_log ("\t%s (%s)", serv2str[req-&gt;type], (char *) key);</span>
<span class='curline'><a href='../S/1660.html#L1163'>req</a>              1163 nscd/connections.c 	dbg_log ("\t%s", serv2str[req-&gt;type]);</span>
<span class='curline'><a href='../S/1660.html#L1167'>req</a>              1167 nscd/connections.c   switch (req-&gt;type)</span>
<span class='curline'><a href='../S/1660.html#L1170'>req</a>              1170 nscd/connections.c       addpwbyname (db, fd, req, key, uid);</span>
<span class='curline'><a href='../S/1660.html#L1174'>req</a>              1174 nscd/connections.c       addpwbyuid (db, fd, req, key, uid);</span>
<span class='curline'><a href='../S/1660.html#L1178'>req</a>              1178 nscd/connections.c       addgrbyname (db, fd, req, key, uid);</span>
<span class='curline'><a href='../S/1660.html#L1182'>req</a>              1182 nscd/connections.c       addgrbygid (db, fd, req, key, uid);</span>
<span class='curline'><a href='../S/1660.html#L1186'>req</a>              1186 nscd/connections.c       addhstbyname (db, fd, req, key, uid);</span>
<span class='curline'><a href='../S/1660.html#L1190'>req</a>              1190 nscd/connections.c       addhstbynamev6 (db, fd, req, key, uid);</span>
<span class='curline'><a href='../S/1660.html#L1194'>req</a>              1194 nscd/connections.c       addhstbyaddr (db, fd, req, key, uid);</span>
<span class='curline'><a href='../S/1660.html#L1198'>req</a>              1198 nscd/connections.c       addhstbyaddrv6 (db, fd, req, key, uid);</span>
<span class='curline'><a href='../S/1660.html#L1202'>req</a>              1202 nscd/connections.c       addhstai (db, fd, req, key, uid);</span>
<span class='curline'><a href='../S/1660.html#L1206'>req</a>              1206 nscd/connections.c       addinitgroups (db, fd, req, key, uid);</span>
<span class='curline'><a href='../S/1660.html#L1210'>req</a>              1210 nscd/connections.c       addservbyname (db, fd, req, key, uid);</span>
<span class='curline'><a href='../S/1660.html#L1214'>req</a>              1214 nscd/connections.c       addservbyport (db, fd, req, key, uid);</span>
<span class='curline'><a href='../S/1660.html#L1218'>req</a>              1218 nscd/connections.c       addgetnetgrent (db, fd, req, key, uid);</span>
<span class='curline'><a href='../S/1660.html#L1222'>req</a>              1222 nscd/connections.c       addinnetgr (db, fd, req, key, uid);</span>
<span class='curline'><a href='../S/1660.html#L1253'>req</a>              1253 nscd/connections.c       if (req-&gt;type == GETSTAT)</span>
<span class='curline'><a href='../S/1660.html#L1260'>req</a>              1260 nscd/connections.c 	  if (req-&gt;type == INVALIDATE)</span>
<span class='curline'><a href='../S/1660.html#L1273'>req</a>              1273 nscd/connections.c       send_ro_fd (reqinfo[req-&gt;type].db, key, fd);</span>
<span class='curline'><a href='../S/1660.html#L1629'>req</a>              1629 nscd/connections.c       request_header req;</span>
<span class='curline'><a href='../S/1660.html#L1630'>req</a>              1630 nscd/connections.c       if (__builtin_expect (TEMP_FAILURE_RETRY (read (fd, &amp;req, sizeof (req)))</span>
<span class='curline'><a href='../S/1660.html#L1631'>req</a>              1631 nscd/connections.c 			    != sizeof (req), 0))</span>
<span class='curline'><a href='../S/1660.html#L1642'>req</a>              1642 nscd/connections.c       if (req.type &lt; GETPWBYNAME || req.type &gt;= LASTREQ)</span>
<span class='curline'><a href='../S/1660.html#L1665'>req</a>              1665 nscd/connections.c       if (__builtin_expect (req.key_len, 1) &lt; 0</span>
<span class='curline'><a href='../S/1660.html#L1666'>req</a>              1666 nscd/connections.c 	  || __builtin_expect (req.key_len, 1) &gt; MAXKEYLEN)</span>
<span class='curline'><a href='../S/1660.html#L1669'>req</a>              1669 nscd/connections.c 	    dbg_log (_("key length in request too long: %d"), req.key_len);</span>
<span class='curline'><a href='../S/1660.html#L1677'>req</a>              1677 nscd/connections.c 							  req.key_len))</span>
<span class='curline'><a href='../S/1660.html#L1678'>req</a>              1678 nscd/connections.c 				!= req.key_len, 0))</span>
<span class='curline'><a href='../S/1660.html#L1686'>req</a>              1686 nscd/connections.c 	  keybuf[req.key_len] = '\0';</span>
<span class='curline'><a href='../S/1660.html#L1694'>req</a>              1694 nscd/connections.c 			 req.version, (long int) pid);</span>
<span class='curline'><a href='../S/1660.html#L1698'>req</a>              1698 nscd/connections.c handle_request: request received (Version = %d)"), req.version);</span>
<span class='curline'><a href='../S/1660.html#L1702'>req</a>              1702 nscd/connections.c 	  handle_request (fd, &amp;req, keybuf, uid, pid);</span>
<span class='curline'><a href='../S/1625.html#L70'>req</a>                70 nscd/grpcache.c cache_addgr (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1625.html#L125'>req</a>               125 nscd/grpcache.c 	  else if ((dataset = mempool_alloc (db, sizeof (struct dataset) + req-&gt;key_len, 1)) != NULL)</span>
<span class='curline'><a href='../S/1625.html#L129'>req</a>               129 nscd/grpcache.c 					    + req-&gt;key_len), total,</span>
<span class='curline'><a href='../S/1625.html#L136'>req</a>               136 nscd/grpcache.c 	      memcpy (dataset-&gt;strdata, key, req-&gt;key_len);</span>
<span class='curline'><a href='../S/1625.html#L145'>req</a>               145 nscd/grpcache.c 			 + sizeof (struct dataset) + req-&gt;key_len, MS_ASYNC);</span>
<span class='curline'><a href='../S/1625.html#L148'>req</a>               148 nscd/grpcache.c 	      (void) cache_add (req-&gt;type, &amp;dataset-&gt;strdata, req-&gt;key_len,</span>
<span class='curline'><a href='../S/1625.html#L343'>req</a>               343 nscd/grpcache.c 	  if (req-&gt;type == GETGRBYGID)</span>
<span class='curline'><a href='../S/1625.html#L362'>req</a>               362 nscd/grpcache.c 	  if ((req-&gt;type == GETGRBYNAME || db-&gt;propagate)</span>
<span class='curline'><a href='../S/1625.html#L369'>req</a>               369 nscd/grpcache.c 	      if (req-&gt;type == GETGRBYNAME &amp;&amp; db-&gt;propagate)</span>
<span class='curline'><a href='../S/1625.html#L411'>req</a>               411 nscd/grpcache.c addgrbyX (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1625.html#L434'>req</a>               434 nscd/grpcache.c   while (lookup (req-&gt;type, key, &amp;resultbuf,</span>
<span class='curline'><a href='../S/1625.html#L450'>req</a>               450 nscd/grpcache.c   time_t timeout = cache_addgr (db, fd, req, keystr, grp, uid, he, dh, errval);</span>
<span class='curline'><a href='../S/1625.html#L457'>req</a>               457 nscd/grpcache.c addgrbyname (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1625.html#L462'>req</a>               462 nscd/grpcache.c   addgrbyX (db, fd, req, u, key, uid, NULL, NULL);</span>
<span class='curline'><a href='../S/1625.html#L470'>req</a>               470 nscd/grpcache.c   request_header req =</span>
<span class='curline'><a href='../S/1625.html#L477'>req</a>               477 nscd/grpcache.c   return addgrbyX (db, -1, &amp;req, u, db-&gt;data + he-&gt;key, he-&gt;owner, he, dh);</span>
<span class='curline'><a href='../S/1625.html#L482'>req</a>               482 nscd/grpcache.c addgrbygid (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1625.html#L499'>req</a>               499 nscd/grpcache.c   addgrbyX (db, fd, req, u, key, uid, NULL, NULL);</span>
<span class='curline'><a href='../S/1625.html#L513'>req</a>               513 nscd/grpcache.c   request_header req =</span>
<span class='curline'><a href='../S/1625.html#L520'>req</a>               520 nscd/grpcache.c   return addgrbyX (db, -1, &amp;req, u, db-&gt;data + he-&gt;key, he-&gt;owner, he, dh);</span>
<span class='curline'><a href='../S/1662.html#L92'>req</a>                92 nscd/hstcache.c cache_addhst (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1662.html#L150'>req</a>               150 nscd/hstcache.c 						  + req-&gt;key_len), 1)) != NULL)</span>
<span class='curline'><a href='../S/1662.html#L154'>req</a>               154 nscd/hstcache.c 					    + req-&gt;key_len), total,</span>
<span class='curline'><a href='../S/1662.html#L162'>req</a>               162 nscd/hstcache.c 	      memcpy (dataset-&gt;strdata, key, req-&gt;key_len);</span>
<span class='curline'><a href='../S/1662.html#L171'>req</a>               171 nscd/hstcache.c 			 + sizeof (struct dataset) + req-&gt;key_len, MS_ASYNC);</span>
<span class='curline'><a href='../S/1662.html#L174'>req</a>               174 nscd/hstcache.c 	      (void) cache_add (req-&gt;type, &amp;dataset-&gt;strdata, req-&gt;key_len,</span>
<span class='curline'><a href='../S/1662.html#L239'>req</a>               239 nscd/hstcache.c 	dataset = (struct dataset *) mempool_alloc (db, total + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1662.html#L247'>req</a>               247 nscd/hstcache.c 	  dataset = (struct dataset *) alloca (total + req-&gt;key_len);</span>
<span class='curline'><a href='../S/1662.html#L253'>req</a>               253 nscd/hstcache.c       timeout = datahead_init_pos (&amp;dataset-&gt;head, total + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1662.html#L294'>req</a>               294 nscd/hstcache.c       key_copy = memcpy (cp, key, req-&gt;key_len);</span>
<span class='curline'><a href='../S/1662.html#L304'>req</a>               304 nscd/hstcache.c 	  if (total + req-&gt;key_len == dh-&gt;allocsize</span>
<span class='curline'><a href='../S/1662.html#L325'>req</a>               325 nscd/hstcache.c 							total + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1662.html#L336'>req</a>               336 nscd/hstcache.c 		      dataset = memcpy (newp, dataset, total + req-&gt;key_len);</span>
<span class='curline'><a href='../S/1662.html#L374'>req</a>               374 nscd/hstcache.c 		     + total + req-&gt;key_len, MS_ASYNC);</span>
<span class='curline'><a href='../S/1662.html#L386'>req</a>               386 nscd/hstcache.c 	  assert (req-&gt;type == GETHOSTBYNAME</span>
<span class='curline'><a href='../S/1662.html#L387'>req</a>               387 nscd/hstcache.c 		  || req-&gt;type == GETHOSTBYNAMEv6</span>
<span class='curline'><a href='../S/1662.html#L388'>req</a>               388 nscd/hstcache.c 		  || req-&gt;type == GETHOSTBYADDR</span>
<span class='curline'><a href='../S/1662.html#L389'>req</a>               389 nscd/hstcache.c 		  || req-&gt;type == GETHOSTBYADDRv6);</span>
<span class='curline'><a href='../S/1662.html#L391'>req</a>               391 nscd/hstcache.c 	  (void) cache_add (req-&gt;type, key_copy, req-&gt;key_len,</span>
<span class='curline'><a href='../S/1662.html#L428'>req</a>               428 nscd/hstcache.c addhstbyX (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1662.html#L444'>req</a>               444 nscd/hstcache.c       if (req-&gt;type == GETHOSTBYNAME || req-&gt;type == GETHOSTBYNAMEv6)</span>
<span class='curline'><a href='../S/1662.html#L447'>req</a>               447 nscd/hstcache.c 	str = inet_ntop (req-&gt;type == GETHOSTBYADDR ? AF_INET : AF_INET6,</span>
<span class='curline'><a href='../S/1662.html#L459'>req</a>               459 nscd/hstcache.c   while (lookup (req-&gt;type, key, &amp;resultbuf,</span>
<span class='curline'><a href='../S/1662.html#L477'>req</a>               477 nscd/hstcache.c   time_t timeout = cache_addhst (db, fd, req, key, hst, uid, he, dh,</span>
<span class='curline'><a href='../S/1662.html#L485'>req</a>               485 nscd/hstcache.c addhstbyname (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1662.html#L488'>req</a>               488 nscd/hstcache.c   addhstbyX (db, fd, req, key, uid, NULL, NULL);</span>
<span class='curline'><a href='../S/1662.html#L496'>req</a>               496 nscd/hstcache.c   request_header req =</span>
<span class='curline'><a href='../S/1662.html#L502'>req</a>               502 nscd/hstcache.c   return addhstbyX (db, -1, &amp;req, db-&gt;data + he-&gt;key, he-&gt;owner, he, dh);</span>
<span class='curline'><a href='../S/1662.html#L507'>req</a>               507 nscd/hstcache.c addhstbyaddr (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1662.html#L510'>req</a>               510 nscd/hstcache.c   addhstbyX (db, fd, req, key, uid, NULL, NULL);</span>
<span class='curline'><a href='../S/1662.html#L518'>req</a>               518 nscd/hstcache.c   request_header req =</span>
<span class='curline'><a href='../S/1662.html#L524'>req</a>               524 nscd/hstcache.c   return addhstbyX (db, -1, &amp;req, db-&gt;data + he-&gt;key, he-&gt;owner, he, dh);</span>
<span class='curline'><a href='../S/1662.html#L529'>req</a>               529 nscd/hstcache.c addhstbynamev6 (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1662.html#L532'>req</a>               532 nscd/hstcache.c   addhstbyX (db, fd, req, key, uid, NULL, NULL);</span>
<span class='curline'><a href='../S/1662.html#L540'>req</a>               540 nscd/hstcache.c   request_header req =</span>
<span class='curline'><a href='../S/1662.html#L546'>req</a>               546 nscd/hstcache.c   return addhstbyX (db, -1, &amp;req, db-&gt;data + he-&gt;key, he-&gt;owner, he, dh);</span>
<span class='curline'><a href='../S/1662.html#L551'>req</a>               551 nscd/hstcache.c addhstbyaddrv6 (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1662.html#L554'>req</a>               554 nscd/hstcache.c   addhstbyX (db, fd, req, key, uid, NULL, NULL);</span>
<span class='curline'><a href='../S/1662.html#L562'>req</a>               562 nscd/hstcache.c   request_header req =</span>
<span class='curline'><a href='../S/1662.html#L568'>req</a>               568 nscd/hstcache.c   return addhstbyX (db, -1, &amp;req, db-&gt;data + he-&gt;key, he-&gt;owner, he, dh);</span>
<span class='curline'><a href='../S/1663.html#L209'>req</a>               209 nscd/initgrcache.c 						  + req-&gt;key_len), 1)) != NULL)</span>
<span class='curline'><a href='../S/1663.html#L213'>req</a>               213 nscd/initgrcache.c 					    + req-&gt;key_len), total,</span>
<span class='curline'><a href='../S/1663.html#L220'>req</a>               220 nscd/initgrcache.c 	      char *key_copy = memcpy (dataset-&gt;strdata, key, req-&gt;key_len);</span>
<span class='curline'><a href='../S/1663.html#L229'>req</a>               229 nscd/initgrcache.c 			 + sizeof (struct dataset) + req-&gt;key_len, MS_ASYNC);</span>
<span class='curline'><a href='../S/1663.html#L232'>req</a>               232 nscd/initgrcache.c 	      (void) cache_add (req-&gt;type, key_copy, req-&gt;key_len,</span>
<span class='curline'><a href='../S/1663.html#L256'>req</a>               256 nscd/initgrcache.c 	dataset = (struct dataset *) mempool_alloc (db, total + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1663.html#L264'>req</a>               264 nscd/initgrcache.c 	  dataset = (struct dataset *) alloca (total + req-&gt;key_len);</span>
<span class='curline'><a href='../S/1663.html#L270'>req</a>               270 nscd/initgrcache.c       timeout = datahead_init_pos (&amp;dataset-&gt;head, total + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1663.html#L296'>req</a>               296 nscd/initgrcache.c       memcpy (cp, key, req-&gt;key_len);</span>
<span class='curline'><a href='../S/1663.html#L307'>req</a>               307 nscd/initgrcache.c 	  if (total + req-&gt;key_len == dh-&gt;allocsize</span>
<span class='curline'><a href='../S/1663.html#L323'>req</a>               323 nscd/initgrcache.c 		= (struct dataset *) mempool_alloc (db, total + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1663.html#L330'>req</a>               330 nscd/initgrcache.c 		  dataset = memcpy (newp, dataset, total + req-&gt;key_len);</span>
<span class='curline'><a href='../S/1663.html#L362'>req</a>               362 nscd/initgrcache.c 		     + req-&gt;key_len, MS_ASYNC);</span>
<span class='curline'><a href='../S/1663.html#L365'>req</a>               365 nscd/initgrcache.c 	  (void) cache_add (INITGROUPS, cp, req-&gt;key_len, &amp;dataset-&gt;head, true,</span>
<span class='curline'><a href='../S/1663.html#L386'>req</a>               386 nscd/initgrcache.c addinitgroups (struct database_dyn *db, int fd, request_header *req, void *key,</span>
<span class='curline'><a href='../S/1663.html#L389'>req</a>               389 nscd/initgrcache.c   addinitgroupsX (db, fd, req, key, uid, NULL, NULL);</span>
<span class='curline'><a href='../S/1663.html#L397'>req</a>               397 nscd/initgrcache.c   request_header req =</span>
<span class='curline'><a href='../S/1663.html#L403'>req</a>               403 nscd/initgrcache.c   return addinitgroupsX (db, -1, &amp;req, db-&gt;data + he-&gt;key, he-&gt;owner, he, dh);</span>
<span class='curline'><a href='../S/1646.html#L74'>req</a>                74 nscd/netgroupcache.c do_notfound (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1646.html#L89'>req</a>                89 nscd/netgroupcache.c   dataset = mempool_alloc (db, sizeof (struct dataset) + req-&gt;key_len, 1);</span>
<span class='curline'><a href='../S/1646.html#L94'>req</a>                94 nscd/netgroupcache.c 				   sizeof (struct dataset) + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1646.html#L101'>req</a>               101 nscd/netgroupcache.c       memcpy (dataset-&gt;strdata, key, req-&gt;key_len);</span>
<span class='curline'><a href='../S/1646.html#L113'>req</a>               113 nscd/netgroupcache.c addgetnetgrentX (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1646.html#L135'>req</a>               135 nscd/netgroupcache.c   size_t buflen = MAX (1024, sizeof (*dataset) + req-&gt;key_len);</span>
<span class='curline'><a href='../S/1646.html#L148'>req</a>               148 nscd/netgroupcache.c       cacheable = do_notfound (db, fd, req, key, &amp;dataset, &amp;total, &amp;timeout,</span>
<span class='curline'><a href='../S/1646.html#L199'>req</a>               199 nscd/netgroupcache.c 				       buflen - buffilled - req-&gt;key_len, &amp;e);</span>
<span class='curline'><a href='../S/1646.html#L231'>req</a>               231 nscd/netgroupcache.c 				if (buflen - req-&gt;key_len - bufused &lt; needed)</span>
<span class='curline'><a href='../S/1646.html#L349'>req</a>               349 nscd/netgroupcache.c       cacheable = do_notfound (db, fd, req, key, &amp;dataset, &amp;total, &amp;timeout,</span>
<span class='curline'><a href='../S/1646.html#L358'>req</a>               358 nscd/netgroupcache.c   timeout = datahead_init_pos (&amp;dataset-&gt;head, total + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1646.html#L368'>req</a>               368 nscd/netgroupcache.c   assert (buflen - buffilled &gt;= req-&gt;key_len);</span>
<span class='curline'><a href='../S/1646.html#L369'>req</a>               369 nscd/netgroupcache.c   key_copy = memcpy (buffer + buffilled, key, req-&gt;key_len);</span>
<span class='curline'><a href='../S/1646.html#L370'>req</a>               370 nscd/netgroupcache.c   buffilled += req-&gt;key_len;</span>
<span class='curline'><a href='../S/1646.html#L397'>req</a>               397 nscd/netgroupcache.c       = (struct dataset *) mempool_alloc (db, total + req-&gt;key_len, 1);</span>
<span class='curline'><a href='../S/1646.html#L403'>req</a>               403 nscd/netgroupcache.c 	dataset = memcpy (newp, dataset, total + req-&gt;key_len);</span>
<span class='curline'><a href='../S/1646.html#L429'>req</a>               429 nscd/netgroupcache.c 		 ((uintptr_t) dataset &amp; pagesize_m1) + total + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1646.html#L433'>req</a>               433 nscd/netgroupcache.c       (void) cache_add (req-&gt;type, key_copy, req-&gt;key_len, &amp;dataset-&gt;head,</span>
<span class='curline'><a href='../S/1646.html#L451'>req</a>               451 nscd/netgroupcache.c addinnetgrX (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1646.html#L503'>req</a>               503 nscd/netgroupcache.c 					    sizeof (*dataset) + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1646.html#L513'>req</a>               513 nscd/netgroupcache.c   datahead_init_pos (&amp;dataset-&gt;head, sizeof (*dataset) + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1646.html#L526'>req</a>               526 nscd/netgroupcache.c   char *key_copy = memcpy ((char *) (dataset + 1), group, req-&gt;key_len);</span>
<span class='curline'><a href='../S/1646.html#L589'>req</a>               589 nscd/netgroupcache.c 		 + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1646.html#L593'>req</a>               593 nscd/netgroupcache.c       (void) cache_add (req-&gt;type, key_copy, req-&gt;key_len, &amp;dataset-&gt;head,</span>
<span class='curline'><a href='../S/1646.html#L610'>req</a>               610 nscd/netgroupcache.c addgetnetgrentX_ignore (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1646.html#L616'>req</a>               616 nscd/netgroupcache.c   time_t timeout = addgetnetgrentX (db, fd, req, key, uid, he, dh,</span>
<span class='curline'><a href='../S/1646.html#L623'>req</a>               623 nscd/netgroupcache.c addgetnetgrent (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1646.html#L626'>req</a>               626 nscd/netgroupcache.c   addgetnetgrentX_ignore (db, fd, req, key, uid, NULL, NULL);</span>
<span class='curline'><a href='../S/1646.html#L634'>req</a>               634 nscd/netgroupcache.c   request_header req =</span>
<span class='curline'><a href='../S/1646.html#L640'>req</a>               640 nscd/netgroupcache.c     (db, -1, &amp;req, db-&gt;data + he-&gt;key, he-&gt;owner, he, dh);</span>
<span class='curline'><a href='../S/1646.html#L645'>req</a>               645 nscd/netgroupcache.c addinnetgr (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1646.html#L648'>req</a>               648 nscd/netgroupcache.c   addinnetgrX (db, fd, req, key, uid, NULL, NULL);</span>
<span class='curline'><a href='../S/1646.html#L656'>req</a>               656 nscd/netgroupcache.c   request_header req =</span>
<span class='curline'><a href='../S/1646.html#L662'>req</a>               662 nscd/netgroupcache.c   return addinnetgrX (db, -1, &amp;req, db-&gt;data + he-&gt;key, he-&gt;owner, he, dh);</span>
<span class='curline'><a href='../S/1630.html#L347'>req</a>               347 nscd/nscd.c        request_header req;</span>
<span class='curline'><a href='../S/1630.html#L351'>req</a>               351 nscd/nscd.c      reqdata-&gt;req.key_len = dbname_len;</span>
<span class='curline'><a href='../S/1630.html#L352'>req</a>               352 nscd/nscd.c      reqdata-&gt;req.version = NSCD_VERSION;</span>
<span class='curline'><a href='../S/1630.html#L353'>req</a>               353 nscd/nscd.c      reqdata-&gt;req.type = INVALIDATE;</span>
<span class='curline'><a href='../S/1630.html#L393'>req</a>               393 nscd/nscd.c      request_header req;</span>
<span class='curline'><a href='../S/1630.html#L394'>req</a>               394 nscd/nscd.c      req.version = NSCD_VERSION;</span>
<span class='curline'><a href='../S/1630.html#L395'>req</a>               395 nscd/nscd.c      req.type = SHUTDOWN;</span>
<span class='curline'><a href='../S/1630.html#L396'>req</a>               396 nscd/nscd.c      req.key_len = 0;</span>
<span class='curline'><a href='../S/1630.html#L398'>req</a>               398 nscd/nscd.c      ssize_t nbytes = TEMP_FAILURE_RETRY (send (sock, &amp;req, sizeof req,</span>
<span class='curline'><a href='../S/1637.html#L287'>req</a>               287 nscd/nscd.h    extern void addpwbyname (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1637.html#L289'>req</a>               289 nscd/nscd.h    extern void addpwbyuid (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1637.html#L297'>req</a>               297 nscd/nscd.h    extern void addgrbyname (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1637.html#L299'>req</a>               299 nscd/nscd.h    extern void addgrbygid (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1637.html#L307'>req</a>               307 nscd/nscd.h    extern void addhstbyname (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1637.html#L309'>req</a>               309 nscd/nscd.h    extern void addhstbyaddr (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1637.html#L312'>req</a>               312 nscd/nscd.h    			    request_header *req, void *key, uid_t uid);</span>
<span class='curline'><a href='../S/1637.html#L314'>req</a>               314 nscd/nscd.h    			    request_header *req, void *key, uid_t uid);</span>
<span class='curline'><a href='../S/1637.html#L325'>req</a>               325 nscd/nscd.h    extern void addhstai (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1637.html#L333'>req</a>               333 nscd/nscd.h    			   request_header *req, void *key, uid_t uid);</span>
<span class='curline'><a href='../S/1637.html#L339'>req</a>               339 nscd/nscd.h    			   request_header *req, void *key, uid_t uid);</span>
<span class='curline'><a href='../S/1637.html#L343'>req</a>               343 nscd/nscd.h    			   request_header *req, void *key, uid_t uid);</span>
<span class='curline'><a href='../S/1637.html#L348'>req</a>               348 nscd/nscd.h    extern void addinnetgr (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1637.html#L353'>req</a>               353 nscd/nscd.h    			    request_header *req, void *key, uid_t uid);</span>
<span class='curline'><a href='../S/1658.html#L178'>req</a>               178 nscd/nscd_helper.c     request_header req;</span>
<span class='curline'><a href='../S/1658.html#L189'>req</a>               189 nscd/nscd_helper.c   reqdata-&gt;req.version = NSCD_VERSION;</span>
<span class='curline'><a href='../S/1658.html#L190'>req</a>               190 nscd/nscd_helper.c   reqdata-&gt;req.type = type;</span>
<span class='curline'><a href='../S/1658.html#L191'>req</a>               191 nscd/nscd_helper.c   reqdata-&gt;req.key_len = keylen;</span>
<span class='curline'><a href='../S/1649.html#L168'>req</a>               168 nscd/nscd_stat.c   request_header req;</span>
<span class='curline'><a href='../S/1649.html#L199'>req</a>               199 nscd/nscd_stat.c   req.version = NSCD_VERSION;</span>
<span class='curline'><a href='../S/1649.html#L200'>req</a>               200 nscd/nscd_stat.c   req.type = GETSTAT;</span>
<span class='curline'><a href='../S/1649.html#L201'>req</a>               201 nscd/nscd_stat.c   req.key_len = 0;</span>
<span class='curline'><a href='../S/1649.html#L202'>req</a>               202 nscd/nscd_stat.c   nbytes = TEMP_FAILURE_RETRY (send (fd, &amp;req, sizeof (request_header),</span>
<span class='curline'><a href='../S/1631.html#L76'>req</a>                76 nscd/pwdcache.c cache_addpw (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1631.html#L132'>req</a>               132 nscd/pwdcache.c 						  + req-&gt;key_len), 1)) != NULL)</span>
<span class='curline'><a href='../S/1631.html#L136'>req</a>               136 nscd/pwdcache.c 					    + req-&gt;key_len), total,</span>
<span class='curline'><a href='../S/1631.html#L143'>req</a>               143 nscd/pwdcache.c 	      char *key_copy = memcpy (dataset-&gt;strdata, key, req-&gt;key_len);</span>
<span class='curline'><a href='../S/1631.html#L152'>req</a>               152 nscd/pwdcache.c 			 + sizeof (struct dataset) + req-&gt;key_len, MS_ASYNC);</span>
<span class='curline'><a href='../S/1631.html#L155'>req</a>               155 nscd/pwdcache.c 	      (void) cache_add (req-&gt;type, key_copy, req-&gt;key_len,</span>
<span class='curline'><a href='../S/1631.html#L322'>req</a>               322 nscd/pwdcache.c 	  if (req-&gt;type == GETPWBYUID)</span>
<span class='curline'><a href='../S/1631.html#L341'>req</a>               341 nscd/pwdcache.c 	  if ((req-&gt;type == GETPWBYNAME || db-&gt;propagate)</span>
<span class='curline'><a href='../S/1631.html#L347'>req</a>               347 nscd/pwdcache.c 	      if (req-&gt;type == GETPWBYNAME &amp;&amp; db-&gt;propagate)</span>
<span class='curline'><a href='../S/1631.html#L389'>req</a>               389 nscd/pwdcache.c addpwbyX (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1631.html#L411'>req</a>               411 nscd/pwdcache.c   while (lookup (req-&gt;type, key, &amp;resultbuf,</span>
<span class='curline'><a href='../S/1631.html#L428'>req</a>               428 nscd/pwdcache.c   time_t timeout = cache_addpw (db, fd, req, keystr, pwd, c_uid, he, dh,</span>
<span class='curline'><a href='../S/1631.html#L436'>req</a>               436 nscd/pwdcache.c addpwbyname (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1631.html#L441'>req</a>               441 nscd/pwdcache.c   addpwbyX (db, fd, req, u, key, c_uid, NULL, NULL);</span>
<span class='curline'><a href='../S/1631.html#L449'>req</a>               449 nscd/pwdcache.c   request_header req =</span>
<span class='curline'><a href='../S/1631.html#L456'>req</a>               456 nscd/pwdcache.c   return addpwbyX (db, -1, &amp;req, u, db-&gt;data + he-&gt;key, he-&gt;owner, he, dh);</span>
<span class='curline'><a href='../S/1631.html#L461'>req</a>               461 nscd/pwdcache.c addpwbyuid (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1631.html#L478'>req</a>               478 nscd/pwdcache.c   addpwbyX (db, fd, req, u, key, c_uid, NULL, NULL);</span>
<span class='curline'><a href='../S/1631.html#L492'>req</a>               492 nscd/pwdcache.c   request_header req =</span>
<span class='curline'><a href='../S/1631.html#L499'>req</a>               499 nscd/pwdcache.c   return addpwbyX (db, -1, &amp;req, u, db-&gt;data + he-&gt;key, he-&gt;owner, he, dh);</span>
<span class='curline'><a href='../S/1641.html#L365'>req</a>               365 nscd/selinux.c nscd_request_avc_has_perm (int fd, request_type req)</span>
<span class='curline'><a href='../S/1641.html#L391'>req</a>               391 nscd/selinux.c   perm = string_to_av_perm (sc_nscd, perms[req]);</span>
<span class='curline'><a href='../S/1641.html#L394'>req</a>               394 nscd/selinux.c 		 "\"%s\" to access vector bit."), perms[req]);</span>
<span class='curline'><a href='../S/1623.html#L39'>req</a>                39 nscd/selinux.h extern int nscd_request_avc_has_perm (int fd, request_type req);</span>
<span class='curline'><a href='../S/1623.html#L55'>req</a>                55 nscd/selinux.h # define nscd_request_avc_has_perm(fd, req) 0</span>
<span class='curline'><a href='../S/1654.html#L64'>req</a>                64 nscd/servicescache.c cache_addserv (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1654.html#L120'>req</a>               120 nscd/servicescache.c 						  + req-&gt;key_len), 1)) != NULL)</span>
<span class='curline'><a href='../S/1654.html#L124'>req</a>               124 nscd/servicescache.c 					    + req-&gt;key_len), total,</span>
<span class='curline'><a href='../S/1654.html#L131'>req</a>               131 nscd/servicescache.c 	      memcpy (dataset-&gt;strdata, key, req-&gt;key_len);</span>
<span class='curline'><a href='../S/1654.html#L140'>req</a>               140 nscd/servicescache.c 			 + sizeof (struct dataset) + req-&gt;key_len, MS_ASYNC);</span>
<span class='curline'><a href='../S/1654.html#L143'>req</a>               143 nscd/servicescache.c 	      (void) cache_add (req-&gt;type, &amp;dataset-&gt;strdata, req-&gt;key_len,</span>
<span class='curline'><a href='../S/1654.html#L191'>req</a>               191 nscd/servicescache.c 	dataset = (struct dataset *) mempool_alloc (db, total + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1654.html#L199'>req</a>               199 nscd/servicescache.c 	  dataset = (struct dataset *) alloca (total + req-&gt;key_len);</span>
<span class='curline'><a href='../S/1654.html#L205'>req</a>               205 nscd/servicescache.c       timeout = datahead_init_pos (&amp;dataset-&gt;head, total + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1654.html#L232'>req</a>               232 nscd/servicescache.c       char *key_copy = memcpy (cp, key, req-&gt;key_len);</span>
<span class='curline'><a href='../S/1654.html#L240'>req</a>               240 nscd/servicescache.c 	  if (total + req-&gt;key_len == dh-&gt;allocsize</span>
<span class='curline'><a href='../S/1654.html#L256'>req</a>               256 nscd/servicescache.c 		= (struct dataset *) mempool_alloc (db, total + req-&gt;key_len,</span>
<span class='curline'><a href='../S/1654.html#L265'>req</a>               265 nscd/servicescache.c 		  dataset = memcpy (newp, dataset, total + req-&gt;key_len);</span>
<span class='curline'><a href='../S/1654.html#L296'>req</a>               296 nscd/servicescache.c 		     + total + req-&gt;key_len, MS_ASYNC);</span>
<span class='curline'><a href='../S/1654.html#L299'>req</a>               299 nscd/servicescache.c 	  (void) cache_add (req-&gt;type, key_copy, req-&gt;key_len,</span>
<span class='curline'><a href='../S/1654.html#L341'>req</a>               341 nscd/servicescache.c addservbyX (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1654.html#L362'>req</a>               362 nscd/servicescache.c   while (lookup (req-&gt;type, key, &amp;resultbuf,</span>
<span class='curline'><a href='../S/1654.html#L378'>req</a>               378 nscd/servicescache.c   time_t timeout = cache_addserv (db, fd, req, key, serv, uid, he, dh, errval);</span>
<span class='curline'><a href='../S/1654.html#L385'>req</a>               385 nscd/servicescache.c addservbyname (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1654.html#L388'>req</a>               388 nscd/servicescache.c   addservbyX (db, fd, req, key, uid, NULL, NULL);</span>
<span class='curline'><a href='../S/1654.html#L396'>req</a>               396 nscd/servicescache.c   request_header req =</span>
<span class='curline'><a href='../S/1654.html#L402'>req</a>               402 nscd/servicescache.c   return addservbyX (db, -1, &amp;req, db-&gt;data + he-&gt;key, he-&gt;owner, he, dh);</span>
<span class='curline'><a href='../S/1654.html#L407'>req</a>               407 nscd/servicescache.c addservbyport (struct database_dyn *db, int fd, request_header *req,</span>
<span class='curline'><a href='../S/1654.html#L410'>req</a>               410 nscd/servicescache.c   addservbyX (db, fd, req, key, uid, NULL, NULL);</span>
<span class='curline'><a href='../S/1654.html#L418'>req</a>               418 nscd/servicescache.c   request_header req =</span>
<span class='curline'><a href='../S/1654.html#L424'>req</a>               424 nscd/servicescache.c   return addservbyX (db, -1, &amp;req, db-&gt;data + he-&gt;key, he-&gt;owner, he, dh);</span>
<span class='curline'><a href='../S/1159.html#L10'>req</a>                10 posix/bug-ga1.c   struct addrinfo req, *ai;</span>
<span class='curline'><a href='../S/1159.html#L13'>req</a>                13 posix/bug-ga1.c   memset (&amp;req, '\0', sizeof req);</span>
<span class='curline'><a href='../S/1159.html#L14'>req</a>                14 posix/bug-ga1.c   req.ai_family = AF_INET6;</span>
<span class='curline'><a href='../S/1159.html#L18'>req</a>                18 posix/bug-ga1.c   getaddrinfo (name, NULL, &amp;req, &amp;ai);</span>
<span class='curline'><a href='../S/1123.html#L23'>req</a>                23 posix/getaddrinfo.c getaddrinfo (const char *name, const char *service, const struct addrinfo *req,</span>
<span class='curline'><a href='../S/6315.html#L23'>req</a>                23 resolv/gai_error.c __gai_error (struct gaicb *req)</span>
<span class='curline'><a href='../S/6315.html#L25'>req</a>                25 resolv/gai_error.c   return req-&gt;__return;</span>
<span class='curline'><a href='../S/6369.html#L324'>req</a>               324 resolv/gai_misc.c 	  struct gaicb *req = runp-&gt;gaicbp;</span>
<span class='curline'><a href='../S/6369.html#L328'>req</a>               328 resolv/gai_misc.c 	  req-&gt;__return = getaddrinfo (req-&gt;ar_name, req-&gt;ar_service,</span>
<span class='curline'><a href='../S/6369.html#L329'>req</a>               329 resolv/gai_misc.c 				       req-&gt;ar_request, &amp;req-&gt;ar_result);</span>
<span class='curline'><a href='../S/6373.html#L89'>req</a>                89 resolv/gai_misc.h extern void __gai_notify (struct requestlist *req)</span>
<span class='curline'><a href='../S/6318.html#L104'>req</a>               104 resolv/gai_notify.c __gai_notify (struct requestlist *req)</span>
<span class='curline'><a href='../S/6318.html#L109'>req</a>               109 resolv/gai_notify.c   waitlist = req-&gt;waiting;</span>
<span class='curline'><a href='../S/1253.html#L43'>req</a>                43 rt/aio_cancel.c   struct requestlist *req = NULL;</span>
<span class='curline'><a href='../S/1253.html#L71'>req</a>                71 rt/aio_cancel.c 	  req = __aio_find_req_fd (fildes);</span>
<span class='curline'><a href='../S/1253.html#L73'>req</a>                73 rt/aio_cancel.c 	  if (req == NULL)</span>
<span class='curline'><a href='../S/1253.html#L81'>req</a>                81 rt/aio_cancel.c 	  while (req-&gt;aiocbp != (aiocb_union *) aiocbp)</span>
<span class='curline'><a href='../S/1253.html#L83'>req</a>                83 rt/aio_cancel.c 	      last = req;</span>
<span class='curline'><a href='../S/1253.html#L84'>req</a>                84 rt/aio_cancel.c 	      req = req-&gt;next_prio;</span>
<span class='curline'><a href='../S/1253.html#L85'>req</a>                85 rt/aio_cancel.c 	      if (req == NULL)</span>
<span class='curline'><a href='../S/1253.html#L90'>req</a>                90 rt/aio_cancel.c 	  if (req-&gt;running == allocated)</span>
<span class='curline'><a href='../S/1253.html#L93'>req</a>                93 rt/aio_cancel.c 	      req = NULL;</span>
<span class='curline'><a href='../S/1253.html#L98'>req</a>                98 rt/aio_cancel.c 	      __aio_remove_request (last, req, 0);</span>
<span class='curline'><a href='../S/1253.html#L102'>req</a>               102 rt/aio_cancel.c 	      req-&gt;next_prio = NULL;</span>
<span class='curline'><a href='../S/1253.html#L110'>req</a>               110 rt/aio_cancel.c       req = __aio_find_req_fd (fildes);</span>
<span class='curline'><a href='../S/1253.html#L114'>req</a>               114 rt/aio_cancel.c       if (req != NULL)</span>
<span class='curline'><a href='../S/1253.html#L116'>req</a>               116 rt/aio_cancel.c 	  if (req-&gt;running == allocated)</span>
<span class='curline'><a href='../S/1253.html#L118'>req</a>               118 rt/aio_cancel.c 	      struct requestlist *old = req;</span>
<span class='curline'><a href='../S/1253.html#L119'>req</a>               119 rt/aio_cancel.c 	      req = req-&gt;next_prio;</span>
<span class='curline'><a href='../S/1253.html#L124'>req</a>               124 rt/aio_cancel.c 	      if (req != NULL)</span>
<span class='curline'><a href='../S/1253.html#L125'>req</a>               125 rt/aio_cancel.c 		__aio_remove_request (old, req, 1);</span>
<span class='curline'><a href='../S/1253.html#L132'>req</a>               132 rt/aio_cancel.c 	      __aio_remove_request (NULL, req, 1);</span>
<span class='curline'><a href='../S/1253.html#L138'>req</a>               138 rt/aio_cancel.c   while (req != NULL)</span>
<span class='curline'><a href='../S/1253.html#L140'>req</a>               140 rt/aio_cancel.c       struct requestlist *old = req;</span>
<span class='curline'><a href='../S/1253.html#L141'>req</a>               141 rt/aio_cancel.c       assert (req-&gt;running == yes || req-&gt;running == queued);</span>
<span class='curline'><a href='../S/1253.html#L142'>req</a>               142 rt/aio_cancel.c       req-&gt;aiocbp-&gt;aiocb.__error_code = ECANCELED;</span>
<span class='curline'><a href='../S/1253.html#L143'>req</a>               143 rt/aio_cancel.c       req-&gt;aiocbp-&gt;aiocb.__return_value = -1;</span>
<span class='curline'><a href='../S/1253.html#L144'>req</a>               144 rt/aio_cancel.c       __aio_notify (req);</span>
<span class='curline'><a href='../S/1253.html#L145'>req</a>               145 rt/aio_cancel.c       req = req-&gt;next_prio;</span>
<span class='curline'><a href='../S/1297.html#L219'>req</a>               219 rt/aio_misc.c  __aio_remove_request (struct requestlist *last, struct requestlist *req,</span>
<span class='curline'><a href='../S/1297.html#L222'>req</a>               222 rt/aio_misc.c    assert (req-&gt;running == yes || req-&gt;running == queued</span>
<span class='curline'><a href='../S/1297.html#L223'>req</a>               223 rt/aio_misc.c  	  || req-&gt;running == done);</span>
<span class='curline'><a href='../S/1297.html#L226'>req</a>               226 rt/aio_misc.c      last-&gt;next_prio = all ? NULL : req-&gt;next_prio;</span>
<span class='curline'><a href='../S/1297.html#L229'>req</a>               229 rt/aio_misc.c        if (all || req-&gt;next_prio == NULL)</span>
<span class='curline'><a href='../S/1297.html#L231'>req</a>               231 rt/aio_misc.c  	  if (req-&gt;last_fd != NULL)</span>
<span class='curline'><a href='../S/1297.html#L232'>req</a>               232 rt/aio_misc.c  	    req-&gt;last_fd-&gt;next_fd = req-&gt;next_fd;</span>
<span class='curline'><a href='../S/1297.html#L234'>req</a>               234 rt/aio_misc.c  	    requests = req-&gt;next_fd;</span>
<span class='curline'><a href='../S/1297.html#L235'>req</a>               235 rt/aio_misc.c  	  if (req-&gt;next_fd != NULL)</span>
<span class='curline'><a href='../S/1297.html#L236'>req</a>               236 rt/aio_misc.c  	    req-&gt;next_fd-&gt;last_fd = req-&gt;last_fd;</span>
<span class='curline'><a href='../S/1297.html#L240'>req</a>               240 rt/aio_misc.c  	  if (req-&gt;last_fd != NULL)</span>
<span class='curline'><a href='../S/1297.html#L241'>req</a>               241 rt/aio_misc.c  	    req-&gt;last_fd-&gt;next_fd = req-&gt;next_prio;</span>
<span class='curline'><a href='../S/1297.html#L243'>req</a>               243 rt/aio_misc.c  	    requests = req-&gt;next_prio;</span>
<span class='curline'><a href='../S/1297.html#L245'>req</a>               245 rt/aio_misc.c  	  if (req-&gt;next_fd != NULL)</span>
<span class='curline'><a href='../S/1297.html#L246'>req</a>               246 rt/aio_misc.c  	    req-&gt;next_fd-&gt;last_fd = req-&gt;next_prio;</span>
<span class='curline'><a href='../S/1297.html#L248'>req</a>               248 rt/aio_misc.c  	  req-&gt;next_prio-&gt;last_fd = req-&gt;last_fd;</span>
<span class='curline'><a href='../S/1297.html#L249'>req</a>               249 rt/aio_misc.c  	  req-&gt;next_prio-&gt;next_fd = req-&gt;next_fd;</span>
<span class='curline'><a href='../S/1297.html#L252'>req</a>               252 rt/aio_misc.c  	  req-&gt;next_prio-&gt;running = yes;</span>
<span class='curline'><a href='../S/1297.html#L255'>req</a>               255 rt/aio_misc.c        if (req-&gt;running == yes)</span>
<span class='curline'><a href='../S/1297.html#L262'>req</a>               262 rt/aio_misc.c  	      if (runp == req)</span>
<span class='curline'><a href='../S/1308.html#L115'>req</a>               115 rt/aio_notify.c __aio_notify (struct requestlist *req)</span>
<span class='curline'><a href='../S/1308.html#L118'>req</a>               118 rt/aio_notify.c   struct aiocb *aiocbp = &amp;req-&gt;aiocbp-&gt;aiocb;</span>
<span class='curline'><a href='../S/1308.html#L129'>req</a>               129 rt/aio_notify.c   waitlist = req-&gt;waiting;</span>
<span class='curline'><a href='../S/1244.html#L76'>req</a>                76 rt/tst-aio10.c   struct aiocb req;</span>
<span class='curline'><a href='../S/1244.html#L77'>req</a>                77 rt/tst-aio10.c   req.aio_fildes = fds[0];</span>
<span class='curline'><a href='../S/1244.html#L78'>req</a>                78 rt/tst-aio10.c   req.aio_lio_opcode = LIO_READ;</span>
<span class='curline'><a href='../S/1244.html#L79'>req</a>                79 rt/tst-aio10.c   req.aio_reqprio = 0;</span>
<span class='curline'><a href='../S/1244.html#L80'>req</a>                80 rt/tst-aio10.c   req.aio_offset = 0;</span>
<span class='curline'><a href='../S/1244.html#L81'>req</a>                81 rt/tst-aio10.c   req.aio_buf = buf;</span>
<span class='curline'><a href='../S/1244.html#L82'>req</a>                82 rt/tst-aio10.c   req.aio_nbytes = sizeof (buf);</span>
<span class='curline'><a href='../S/1244.html#L83'>req</a>                83 rt/tst-aio10.c   req.aio_sigevent.sigev_notify = SIGEV_NONE;</span>
<span class='curline'><a href='../S/1244.html#L100'>req</a>               100 rt/tst-aio10.c   list[0] = &amp;req;</span>
<span class='curline'><a href='../S/1260.html#L18'>req</a>                18 rt/tst-aio8.c    struct aiocb req;</span>
<span class='curline'><a href='../S/1260.html#L19'>req</a>                19 rt/tst-aio8.c    req.aio_fildes = fd;</span>
<span class='curline'><a href='../S/1260.html#L20'>req</a>                20 rt/tst-aio8.c    req.aio_lio_opcode = LIO_WRITE;</span>
<span class='curline'><a href='../S/1260.html#L21'>req</a>                21 rt/tst-aio8.c    req.aio_reqprio = 0;</span>
<span class='curline'><a href='../S/1260.html#L22'>req</a>                22 rt/tst-aio8.c    req.aio_buf = (void *) "hello";</span>
<span class='curline'><a href='../S/1260.html#L23'>req</a>                23 rt/tst-aio8.c    req.aio_nbytes = 5;</span>
<span class='curline'><a href='../S/1260.html#L24'>req</a>                24 rt/tst-aio8.c    req.aio_offset = 0;</span>
<span class='curline'><a href='../S/1260.html#L25'>req</a>                25 rt/tst-aio8.c    req.aio_sigevent.sigev_notify = SIGEV_NONE;</span>
<span class='curline'><a href='../S/1260.html#L28'>req</a>                28 rt/tst-aio8.c    list[0] = &amp;req;</span>
<span class='curline'><a href='../S/1238.html#L76'>req</a>                76 rt/tst-aio9.c    struct aiocb req;</span>
<span class='curline'><a href='../S/1238.html#L77'>req</a>                77 rt/tst-aio9.c    req.aio_fildes = fds[0];</span>
<span class='curline'><a href='../S/1238.html#L78'>req</a>                78 rt/tst-aio9.c    req.aio_reqprio = 0;</span>
<span class='curline'><a href='../S/1238.html#L79'>req</a>                79 rt/tst-aio9.c    req.aio_offset = 0;</span>
<span class='curline'><a href='../S/1238.html#L80'>req</a>                80 rt/tst-aio9.c    req.aio_buf = buf;</span>
<span class='curline'><a href='../S/1238.html#L81'>req</a>                81 rt/tst-aio9.c    req.aio_nbytes = sizeof (buf);</span>
<span class='curline'><a href='../S/1238.html#L82'>req</a>                82 rt/tst-aio9.c    req.aio_sigevent.sigev_notify = SIGEV_NONE;</span>
<span class='curline'><a href='../S/1238.html#L84'>req</a>                84 rt/tst-aio9.c    if (aio_read (&amp;req) != 0)</span>
<span class='curline'><a href='../S/1238.html#L105'>req</a>               105 rt/tst-aio9.c    list[0] = &amp;req;</span>
<span class='curline'><a href='../S/5941.html#L48'>req</a>                48 support/support_enter_network_namespace.c       struct ifreq req;</span>
<span class='curline'><a href='../S/5941.html#L49'>req</a>                49 support/support_enter_network_namespace.c       strcpy (req.ifr_name, "lo");</span>
<span class='curline'><a href='../S/5941.html#L50'>req</a>                50 support/support_enter_network_namespace.c       TEST_VERIFY_EXIT (ioctl (fd, SIOCGIFFLAGS, &amp;req) == 0);</span>
<span class='curline'><a href='../S/5941.html#L51'>req</a>                51 support/support_enter_network_namespace.c       bool already_up = req.ifr_flags &amp; IFF_UP;</span>
<span class='curline'><a href='../S/5941.html#L59'>req</a>                59 support/support_enter_network_namespace.c           req.ifr_flags |= IFF_UP | IFF_RUNNING;</span>
<span class='curline'><a href='../S/5941.html#L60'>req</a>                60 support/support_enter_network_namespace.c           TEST_VERIFY_EXIT (ioctl (fd, SIOCSIFFLAGS, &amp;req) == 0);</span>
<span class='curline'><a href='../S/12316.html#L106'>req</a>               106 sysdeps/generic/aio_misc.h 				  struct requestlist *req, int all)</span>
<span class='curline'><a href='../S/12316.html#L110'>req</a>               110 sysdeps/generic/aio_misc.h extern void __aio_free_request (struct requestlist *req) attribute_hidden;</span>
<span class='curline'><a href='../S/12316.html#L113'>req</a>               113 sysdeps/generic/aio_misc.h extern void __aio_notify (struct requestlist *req) attribute_hidden;</span>
<span class='curline'><a href='../S/14276.html#L28'>req</a>                28 sysdeps/mach/clock_nanosleep.c nanosleep_call (const struct timespec *req, struct timespec *rem)</span>
<span class='curline'><a href='../S/14276.html#L35'>req</a>                35 sysdeps/mach/clock_nanosleep.c     = req-&gt;tv_sec * 1000</span>
<span class='curline'><a href='../S/14276.html#L36'>req</a>                36 sysdeps/mach/clock_nanosleep.c     + (req-&gt;tv_nsec + 999999) / 1000000;</span>
<span class='curline'><a href='../S/14276.html#L57'>req</a>                57 sysdeps/mach/clock_nanosleep.c 	  timespec_sub (rem, req, &amp;elapsed);</span>
<span class='curline'><a href='../S/14276.html#L67'>req</a>                67 sysdeps/mach/clock_nanosleep.c __clock_nanosleep (clockid_t clock_id, int flags, const struct timespec *req,</span>
<span class='curline'><a href='../S/14276.html#L71'>req</a>                71 sysdeps/mach/clock_nanosleep.c       || !valid_nanoseconds (req-&gt;tv_nsec)</span>
<span class='curline'><a href='../S/14276.html#L91'>req</a>                91 sysdeps/mach/clock_nanosleep.c       nsec = req-&gt;tv_nsec - now.tv_nsec;</span>
<span class='curline'><a href='../S/14276.html#L92'>req</a>                92 sysdeps/mach/clock_nanosleep.c       sec = req-&gt;tv_sec - now.tv_sec - (nsec &lt; 0);</span>
<span class='curline'><a href='../S/14276.html#L101'>req</a>               101 sysdeps/mach/clock_nanosleep.c       req = &amp;now;</span>
<span class='curline'><a href='../S/14276.html#L107'>req</a>               107 sysdeps/mach/clock_nanosleep.c   return nanosleep_call (req, rem);</span>
<span class='curline'><a href='../S/14240.html#L134'>req</a>               134 sysdeps/mach/hurd/net/if_arp.h     unsigned short int req;		/* Request type.  */</span>
<span class='curline'><a href='../S/8330.html#L263'>req</a>               263 sysdeps/mips/tst-abi-interlink.c   struct fp_mode_req req = compute_fp_modes (s);</span>
<span class='curline'><a href='../S/8330.html#L264'>req</a>               264 sysdeps/mips/tst-abi-interlink.c   return (req.mode1 == current_fp_mode</span>
<span class='curline'><a href='../S/8330.html#L265'>req</a>               265 sysdeps/mips/tst-abi-interlink.c 	  || req.mode2 == current_fp_mode</span>
<span class='curline'><a href='../S/8330.html#L266'>req</a>               266 sysdeps/mips/tst-abi-interlink.c 	  || req.mode3 == current_fp_mode);</span>
<span class='curline'><a href='../S/8414.html#L159'>req</a>               159 sysdeps/posix/getaddrinfo.c 		const struct addrinfo *req, struct gaih_servtuple *st,</span>
<span class='curline'><a href='../S/8414.html#L186'>req</a>               186 sysdeps/posix/getaddrinfo.c 		  ? req-&gt;ai_protocol : tp-&gt;protocol);</span>
<span class='curline'><a href='../S/8414.html#L197'>req</a>               197 sysdeps/posix/getaddrinfo.c convert_hostent_to_gaih_addrtuple (const struct addrinfo *req,</span>
<span class='curline'><a href='../S/8414.html#L221'>req</a>               221 sysdeps/posix/getaddrinfo.c       if (family == AF_INET &amp;&amp; req-&gt;ai_family == AF_INET6)</span>
<span class='curline'><a href='../S/8414.html#L278'>req</a>               278 sysdeps/posix/getaddrinfo.c       if (!convert_hostent_to_gaih_addrtuple (req, _family, &amp;th, &amp;addrmem))   \</span>
<span class='curline'><a href='../S/8414.html#L328'>req</a>               328 sysdeps/posix/getaddrinfo.c 	   const struct addrinfo *req, struct addrinfo **pai,</span>
<span class='curline'><a href='../S/8414.html#L342'>req</a>               342 sysdeps/posix/getaddrinfo.c   if (req-&gt;ai_protocol || req-&gt;ai_socktype)</span>
<span class='curline'><a href='../S/8414.html#L347'>req</a>               347 sysdeps/posix/getaddrinfo.c 	     &amp;&amp; ((req-&gt;ai_socktype != 0 &amp;&amp; req-&gt;ai_socktype != tp-&gt;socktype)</span>
<span class='curline'><a href='../S/8414.html#L348'>req</a>               348 sysdeps/posix/getaddrinfo.c 		 || (req-&gt;ai_protocol != 0</span>
<span class='curline'><a href='../S/8414.html#L350'>req</a>               350 sysdeps/posix/getaddrinfo.c 		     &amp;&amp; req-&gt;ai_protocol != tp-&gt;protocol)))</span>
<span class='curline'><a href='../S/8414.html#L355'>req</a>               355 sysdeps/posix/getaddrinfo.c 	  if (req-&gt;ai_socktype)</span>
<span class='curline'><a href='../S/8414.html#L375'>req</a>               375 sysdeps/posix/getaddrinfo.c 	      int rc = gaih_inet_serv (service-&gt;name, tp, req, st, tmpbuf);</span>
<span class='curline'><a href='../S/8414.html#L389'>req</a>               389 sysdeps/posix/getaddrinfo.c 		  if (req-&gt;ai_socktype != 0</span>
<span class='curline'><a href='../S/8414.html#L390'>req</a>               390 sysdeps/posix/getaddrinfo.c 		      &amp;&amp; req-&gt;ai_socktype != tp-&gt;socktype)</span>
<span class='curline'><a href='../S/8414.html#L392'>req</a>               392 sysdeps/posix/getaddrinfo.c 		  if (req-&gt;ai_protocol != 0</span>
<span class='curline'><a href='../S/8414.html#L394'>req</a>               394 sysdeps/posix/getaddrinfo.c 		      &amp;&amp; req-&gt;ai_protocol != tp-&gt;protocol)</span>
<span class='curline'><a href='../S/8414.html#L402'>req</a>               402 sysdeps/posix/getaddrinfo.c 				      tp, req, newp, tmpbuf) != 0)</span>
<span class='curline'><a href='../S/8414.html#L422'>req</a>               422 sysdeps/posix/getaddrinfo.c       if (req-&gt;ai_socktype || req-&gt;ai_protocol)</span>
<span class='curline'><a href='../S/8414.html#L428'>req</a>               428 sysdeps/posix/getaddrinfo.c 			  ? req-&gt;ai_protocol : tp-&gt;protocol);</span>
<span class='curline'><a href='../S/8414.html#L466'>req</a>               466 sysdeps/posix/getaddrinfo.c       if (req-&gt;ai_flags &amp; AI_IDN)</span>
<span class='curline'><a href='../S/8414.html#L478'>req</a>               478 sysdeps/posix/getaddrinfo.c 	  if (req-&gt;ai_family == AF_UNSPEC || req-&gt;ai_family == AF_INET)</span>
<span class='curline'><a href='../S/8414.html#L480'>req</a>               480 sysdeps/posix/getaddrinfo.c 	  else if (req-&gt;ai_family == AF_INET6 &amp;&amp; (req-&gt;ai_flags &amp; AI_V4MAPPED))</span>
<span class='curline'><a href='../S/8414.html#L494'>req</a>               494 sysdeps/posix/getaddrinfo.c 	  if (req-&gt;ai_flags &amp; AI_CANONNAME)</span>
<span class='curline'><a href='../S/8414.html#L508'>req</a>               508 sysdeps/posix/getaddrinfo.c 	      if (req-&gt;ai_family == AF_UNSPEC || req-&gt;ai_family == AF_INET6)</span>
<span class='curline'><a href='../S/8414.html#L510'>req</a>               510 sysdeps/posix/getaddrinfo.c 	      else if (req-&gt;ai_family == AF_INET</span>
<span class='curline'><a href='../S/8414.html#L531'>req</a>               531 sysdeps/posix/getaddrinfo.c 	      if (req-&gt;ai_flags &amp; AI_CANONNAME)</span>
<span class='curline'><a href='../S/8414.html#L536'>req</a>               536 sysdeps/posix/getaddrinfo.c       if (at-&gt;family == AF_UNSPEC &amp;&amp; (req-&gt;ai_flags &amp; AI_NUMERICHOST) == 0)</span>
<span class='curline'><a href='../S/8414.html#L550'>req</a>               550 sysdeps/posix/getaddrinfo.c 	  if (req-&gt;ai_family == AF_INET</span>
<span class='curline'><a href='../S/8414.html#L551'>req</a>               551 sysdeps/posix/getaddrinfo.c 	      &amp;&amp; (req-&gt;ai_flags &amp; AI_CANONNAME) == 0)</span>
<span class='curline'><a href='../S/8414.html#L577'>req</a>               577 sysdeps/posix/getaddrinfo.c 			  (req, AF_INET, h, &amp;addrmem))</span>
<span class='curline'><a href='../S/8414.html#L624'>req</a>               624 sysdeps/posix/getaddrinfo.c 		  bool added_canon = (req-&gt;ai_flags &amp; AI_CANONNAME) == 0;</span>
<span class='curline'><a href='../S/8414.html#L641'>req</a>               641 sysdeps/posix/getaddrinfo.c 			     &amp;&amp; req-&gt;ai_family == AF_INET6</span>
<span class='curline'><a href='../S/8414.html#L642'>req</a>               642 sysdeps/posix/getaddrinfo.c 			     &amp;&amp; (req-&gt;ai_flags &amp; AI_V4MAPPED) != 0)</span>
<span class='curline'><a href='../S/8414.html#L643'>req</a>               643 sysdeps/posix/getaddrinfo.c 			    || req-&gt;ai_family == AF_UNSPEC</span>
<span class='curline'><a href='../S/8414.html#L644'>req</a>               644 sysdeps/posix/getaddrinfo.c 			    || air-&gt;family[i] == req-&gt;ai_family))</span>
<span class='curline'><a href='../S/8414.html#L672'>req</a>               672 sysdeps/posix/getaddrinfo.c 			  &amp;&amp; req-&gt;ai_family == AF_INET6</span>
<span class='curline'><a href='../S/8414.html#L673'>req</a>               673 sysdeps/posix/getaddrinfo.c 			  &amp;&amp; (req-&gt;ai_flags &amp; AI_V4MAPPED))</span>
<span class='curline'><a href='../S/8414.html#L683'>req</a>               683 sysdeps/posix/getaddrinfo.c 		      else if (req-&gt;ai_family == AF_UNSPEC</span>
<span class='curline'><a href='../S/8414.html#L684'>req</a>               684 sysdeps/posix/getaddrinfo.c 			       || air-&gt;family[i] == req-&gt;ai_family)</span>
<span class='curline'><a href='../S/8414.html#L740'>req</a>               740 sysdeps/posix/getaddrinfo.c 	      if (req-&gt;ai_family == PF_UNSPEC)</span>
<span class='curline'><a href='../S/8414.html#L776'>req</a>               776 sysdeps/posix/getaddrinfo.c 		      if ((req-&gt;ai_flags &amp; AI_CANONNAME) != 0 &amp;&amp; canon == NULL)</span>
<span class='curline'><a href='../S/8414.html#L782'>req</a>               782 sysdeps/posix/getaddrinfo.c 			      &amp;&amp; req-&gt;ai_family == AF_INET6</span>
<span class='curline'><a href='../S/8414.html#L783'>req</a>               783 sysdeps/posix/getaddrinfo.c 			      &amp;&amp; (req-&gt;ai_flags &amp; AI_V4MAPPED) != 0)</span>
<span class='curline'><a href='../S/8414.html#L794'>req</a>               794 sysdeps/posix/getaddrinfo.c 			  else if (req-&gt;ai_family == AF_UNSPEC</span>
<span class='curline'><a href='../S/8414.html#L795'>req</a>               795 sysdeps/posix/getaddrinfo.c 				   || (*pat)-&gt;family == req-&gt;ai_family)</span>
<span class='curline'><a href='../S/8414.html#L800'>req</a>               800 sysdeps/posix/getaddrinfo.c 			      if (req-&gt;ai_family == AF_INET6)</span>
<span class='curline'><a href='../S/8414.html#L813'>req</a>               813 sysdeps/posix/getaddrinfo.c 		  if (req-&gt;ai_flags &amp; AI_CANONNAME)</span>
<span class='curline'><a href='../S/8414.html#L829'>req</a>               829 sysdeps/posix/getaddrinfo.c 		      if (req-&gt;ai_family == AF_INET6</span>
<span class='curline'><a href='../S/8414.html#L830'>req</a>               830 sysdeps/posix/getaddrinfo.c 			  || req-&gt;ai_family == AF_UNSPEC)</span>
<span class='curline'><a href='../S/8414.html#L836'>req</a>               836 sysdeps/posix/getaddrinfo.c 		      if (req-&gt;ai_family == AF_INET</span>
<span class='curline'><a href='../S/8414.html#L837'>req</a>               837 sysdeps/posix/getaddrinfo.c 			  || req-&gt;ai_family == AF_UNSPEC</span>
<span class='curline'><a href='../S/8414.html#L838'>req</a>               838 sysdeps/posix/getaddrinfo.c 			  || (req-&gt;ai_family == AF_INET6</span>
<span class='curline'><a href='../S/8414.html#L839'>req</a>               839 sysdeps/posix/getaddrinfo.c 			      &amp;&amp; (req-&gt;ai_flags &amp; AI_V4MAPPED)</span>
<span class='curline'><a href='../S/8414.html#L842'>req</a>               842 sysdeps/posix/getaddrinfo.c 			      &amp;&amp; ((req-&gt;ai_flags &amp; AI_ALL) || !got_ipv6)))</span>
<span class='curline'><a href='../S/8414.html#L846'>req</a>               846 sysdeps/posix/getaddrinfo.c 			  if (req-&gt;ai_family == AF_INET)</span>
<span class='curline'><a href='../S/8414.html#L858'>req</a>               858 sysdeps/posix/getaddrinfo.c 			  if ((req-&gt;ai_flags &amp; AI_CANONNAME) != 0</span>
<span class='curline'><a href='../S/8414.html#L945'>req</a>               945 sysdeps/posix/getaddrinfo.c       if (req-&gt;ai_family == AF_UNSPEC)</span>
<span class='curline'><a href='../S/8414.html#L951'>req</a>               951 sysdeps/posix/getaddrinfo.c       if (req-&gt;ai_family == AF_UNSPEC || req-&gt;ai_family == AF_INET6)</span>
<span class='curline'><a href='../S/8414.html#L954'>req</a>               954 sysdeps/posix/getaddrinfo.c 	  if ((req-&gt;ai_flags &amp; AI_PASSIVE) == 0)</span>
<span class='curline'><a href='../S/8414.html#L959'>req</a>               959 sysdeps/posix/getaddrinfo.c       if (req-&gt;ai_family == AF_UNSPEC || req-&gt;ai_family == AF_INET)</span>
<span class='curline'><a href='../S/8414.html#L962'>req</a>               962 sysdeps/posix/getaddrinfo.c 	  if ((req-&gt;ai_flags &amp; AI_PASSIVE) == 0)</span>
<span class='curline'><a href='../S/8414.html#L979'>req</a>               979 sysdeps/posix/getaddrinfo.c 	if (at2 == at &amp;&amp; (req-&gt;ai_flags &amp; AI_CANONNAME) != 0)</span>
<span class='curline'><a href='../S/8414.html#L986'>req</a>               986 sysdeps/posix/getaddrinfo.c 	    bool do_idn = req-&gt;ai_flags &amp; AI_CANONIDN;</span>
<span class='curline'><a href='../S/8414.html#L1029'>req</a>              1029 sysdeps/posix/getaddrinfo.c 		&amp;&amp; (req-&gt;ai_flags &amp; (AI_V4MAPPED|AI_ALL)) == AI_V4MAPPED</span>
<span class='curline'><a href='../S/8414.html#L1047'>req</a>              1047 sysdeps/posix/getaddrinfo.c 	    ai-&gt;ai_flags = req-&gt;ai_flags;</span>
<span class='curline'><a href='../S/10882.html#L69'>req</a>                69 sysdeps/unix/sysv/linux/check_native.c   } req;</span>
<span class='curline'><a href='../S/10882.html#L71'>req</a>                71 sysdeps/unix/sysv/linux/check_native.c   req.nlh.nlmsg_len = sizeof (req);</span>
<span class='curline'><a href='../S/10882.html#L72'>req</a>                72 sysdeps/unix/sysv/linux/check_native.c   req.nlh.nlmsg_type = RTM_GETLINK;</span>
<span class='curline'><a href='../S/10882.html#L73'>req</a>                73 sysdeps/unix/sysv/linux/check_native.c   req.nlh.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;</span>
<span class='curline'><a href='../S/10882.html#L74'>req</a>                74 sysdeps/unix/sysv/linux/check_native.c   req.nlh.nlmsg_pid = 0;</span>
<span class='curline'><a href='../S/10882.html#L75'>req</a>                75 sysdeps/unix/sysv/linux/check_native.c   req.nlh.nlmsg_seq = time_now ();</span>
<span class='curline'><a href='../S/10882.html#L76'>req</a>                76 sysdeps/unix/sysv/linux/check_native.c   req.g.rtgen_family = AF_UNSPEC;</span>
<span class='curline'><a href='../S/10882.html#L78'>req</a>                78 sysdeps/unix/sysv/linux/check_native.c   assert (sizeof (req) - offsetof (struct req, pad) == 3);</span>
<span class='curline'><a href='../S/10882.html#L79'>req</a>                79 sysdeps/unix/sysv/linux/check_native.c   memset (req.pad, '\0', sizeof (req.pad));</span>
<span class='curline'><a href='../S/10882.html#L106'>req</a>               106 sysdeps/unix/sysv/linux/check_native.c   if (TEMP_FAILURE_RETRY (__sendto (fd, (void *) &amp;req, sizeof (req), 0,</span>
<span class='curline'><a href='../S/10882.html#L139'>req</a>               139 sysdeps/unix/sysv/linux/check_native.c 	      || nlmh-&gt;nlmsg_seq != req.nlh.nlmsg_seq)</span>
<span class='curline'><a href='../S/11394.html#L122'>req</a>               122 sysdeps/unix/sysv/linux/check_pf.c   } req;</span>
<span class='curline'><a href='../S/11394.html#L125'>req</a>               125 sysdeps/unix/sysv/linux/check_pf.c   req.nlh.nlmsg_len = sizeof (req);</span>
<span class='curline'><a href='../S/11394.html#L126'>req</a>               126 sysdeps/unix/sysv/linux/check_pf.c   req.nlh.nlmsg_type = RTM_GETADDR;</span>
<span class='curline'><a href='../S/11394.html#L127'>req</a>               127 sysdeps/unix/sysv/linux/check_pf.c   req.nlh.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;</span>
<span class='curline'><a href='../S/11394.html#L128'>req</a>               128 sysdeps/unix/sysv/linux/check_pf.c   req.nlh.nlmsg_pid = 0;</span>
<span class='curline'><a href='../S/11394.html#L129'>req</a>               129 sysdeps/unix/sysv/linux/check_pf.c   req.nlh.nlmsg_seq = time_now ();</span>
<span class='curline'><a href='../S/11394.html#L130'>req</a>               130 sysdeps/unix/sysv/linux/check_pf.c   req.g.rtgen_family = AF_UNSPEC;</span>
<span class='curline'><a href='../S/11394.html#L132'>req</a>               132 sysdeps/unix/sysv/linux/check_pf.c   assert (sizeof (req) - offsetof (struct req, pad) == 3);</span>
<span class='curline'><a href='../S/11394.html#L133'>req</a>               133 sysdeps/unix/sysv/linux/check_pf.c   memset (req.pad, '\0', sizeof (req.pad));</span>
<span class='curline'><a href='../S/11394.html#L147'>req</a>               147 sysdeps/unix/sysv/linux/check_pf.c   if (TEMP_FAILURE_RETRY (__sendto (fd, (void *) &amp;req, sizeof (req), 0,</span>
<span class='curline'><a href='../S/11394.html#L184'>req</a>               184 sysdeps/unix/sysv/linux/check_pf.c 	      || nlmh-&gt;nlmsg_seq != req.nlh.nlmsg_seq)</span>
<span class='curline'><a href='../S/11409.html#L31'>req</a>                31 sysdeps/unix/sysv/linux/clock_nanosleep.c 			  const struct __timespec64 *req,</span>
<span class='curline'><a href='../S/11409.html#L48'>req</a>                48 sysdeps/unix/sysv/linux/clock_nanosleep.c   r = INTERNAL_SYSCALL_CANCEL (clock_nanosleep_time64, clock_id, flags, req,</span>
<span class='curline'><a href='../S/11409.html#L51'>req</a>                51 sysdeps/unix/sysv/linux/clock_nanosleep.c   if (!in_time_t_range (req-&gt;tv_sec))</span>
<span class='curline'><a href='../S/11409.html#L54'>req</a>                54 sysdeps/unix/sysv/linux/clock_nanosleep.c 				   req, rem);</span>
<span class='curline'><a href='../S/11409.html#L61'>req</a>                61 sysdeps/unix/sysv/linux/clock_nanosleep.c       struct timespec ts32 = valid_timespec64_to_timespec (*req);</span>
<span class='curline'><a href='../S/11409.html#L78'>req</a>                78 sysdeps/unix/sysv/linux/clock_nanosleep.c __clock_nanosleep (clockid_t clock_id, int flags, const struct timespec *req,</span>
<span class='curline'><a href='../S/11409.html#L84'>req</a>                84 sysdeps/unix/sysv/linux/clock_nanosleep.c   treq64 = valid_timespec_to_timespec64 (*req);</span>
<span class='curline'><a href='../S/9736.html#L101'>req</a>               101 sysdeps/unix/sysv/linux/ifaddrs.c   } req;</span>
<span class='curline'><a href='../S/9736.html#L107'>req</a>               107 sysdeps/unix/sysv/linux/ifaddrs.c   req.nlh.nlmsg_len = sizeof (req);</span>
<span class='curline'><a href='../S/9736.html#L108'>req</a>               108 sysdeps/unix/sysv/linux/ifaddrs.c   req.nlh.nlmsg_type = type;</span>
<span class='curline'><a href='../S/9736.html#L109'>req</a>               109 sysdeps/unix/sysv/linux/ifaddrs.c   req.nlh.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;</span>
<span class='curline'><a href='../S/9736.html#L110'>req</a>               110 sysdeps/unix/sysv/linux/ifaddrs.c   req.nlh.nlmsg_pid = 0;</span>
<span class='curline'><a href='../S/9736.html#L111'>req</a>               111 sysdeps/unix/sysv/linux/ifaddrs.c   req.nlh.nlmsg_seq = h-&gt;seq;</span>
<span class='curline'><a href='../S/9736.html#L112'>req</a>               112 sysdeps/unix/sysv/linux/ifaddrs.c   req.g.rtgen_family = AF_UNSPEC;</span>
<span class='curline'><a href='../S/9736.html#L113'>req</a>               113 sysdeps/unix/sysv/linux/ifaddrs.c   if (sizeof (req) != offsetof (struct req, pad))</span>
<span class='curline'><a href='../S/9736.html#L114'>req</a>               114 sysdeps/unix/sysv/linux/ifaddrs.c     memset (req.pad, '\0', sizeof (req) - offsetof (struct req, pad));</span>
<span class='curline'><a href='../S/9736.html#L119'>req</a>               119 sysdeps/unix/sysv/linux/ifaddrs.c   return TEMP_FAILURE_RETRY (__sendto (h-&gt;fd, (void *) &amp;req, sizeof (req), 0,</span>
<span class='curline'><a href='../S/11825.html#L23'>req</a>                23 sysdeps/unix/sysv/linux/nanosleep.c __nanosleep64 (const struct __timespec64 *req, struct __timespec64 *rem)</span>
<span class='curline'><a href='../S/11825.html#L25'>req</a>                25 sysdeps/unix/sysv/linux/nanosleep.c   int ret = __clock_nanosleep_time64 (CLOCK_REALTIME, 0, req, rem);</span>
<span class='curline'><a href='../S/11825.html#L37'>req</a>                37 sysdeps/unix/sysv/linux/nanosleep.c __nanosleep (const struct timespec *req, struct timespec *rem)</span>
<span class='curline'><a href='../S/11825.html#L41'>req</a>                41 sysdeps/unix/sysv/linux/nanosleep.c   treq64 = valid_timespec_to_timespec64 (*req);</span>
<span class='curline'><a href='../S/12048.html#L174'>req</a>               174 sysdeps/unix/sysv/linux/net/if_arp.h     unsigned short int req;		/* Request type.  */</span>
<span class='curline'><a href='../S/4076.html#L24'>req</a>                24 time/clock_nanosleep.c __clock_nanosleep (clockid_t clock_id, int flags, const struct timespec *req,</span>
<span class='curline'><a href='../S/4076.html#L27'>req</a>                27 time/clock_nanosleep.c   if (! valid_nanoseconds (req-&gt;tv_nsec))</span>
</pre>
</body>
</html>
