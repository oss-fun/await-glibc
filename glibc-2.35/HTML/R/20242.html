<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>handle</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-6.6.12' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/1435.html#L7'>handle</a>              7 dlfcn/bug-atexit3.c   void *handle = dlopen ("$ORIGIN/bug-atexit3-lib.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/1435.html#L8'>handle</a>              8 dlfcn/bug-atexit3.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1435.html#L13'>handle</a>             13 dlfcn/bug-atexit3.c   dlclose (handle);</span>
<span class='curline'><a href='../S/1451.html#L10'>handle</a>             10 dlfcn/bug-dlsym1.c     void *handle;</span>
<span class='curline'><a href='../S/1451.html#L15'>handle</a>             15 dlfcn/bug-dlsym1.c     if ((handle = dlopen("bug-dlsym1-lib1.so", RTLD_NOW)) == NULL) {</span>
<span class='curline'><a href='../S/1451.html#L20'>handle</a>             20 dlfcn/bug-dlsym1.c     if ((c = dlsym(handle, "dlopen_test_variable")) == NULL) {</span>
<span class='curline'><a href='../S/1451.html#L25'>handle</a>             25 dlfcn/bug-dlsym1.c     (void) dlclose(handle);</span>
<span class='curline'><a href='../S/1439.html#L24'>handle</a>             24 dlfcn/dlclose.c __dlclose (void *handle)</span>
<span class='curline'><a href='../S/1439.html#L28'>handle</a>             28 dlfcn/dlclose.c     return GLRO (dl_dlfcn_hook)-&gt;dlclose (handle);</span>
<span class='curline'><a href='../S/1439.html#L31'>handle</a>             31 dlfcn/dlclose.c   return _dlerror_run (GLRO (dl_close), handle) ? -1 : 0;</span>
<span class='curline'><a href='../S/1415.html#L28'>handle</a>             28 dlfcn/dlinfo.c   void *handle;</span>
<span class='curline'><a href='../S/1415.html#L37'>handle</a>             37 dlfcn/dlinfo.c   struct link_map *l = args-&gt;handle;</span>
<span class='curline'><a href='../S/1415.html#L82'>handle</a>             82 dlfcn/dlinfo.c dlinfo_implementation (void *handle, int request, void *arg)</span>
<span class='curline'><a href='../S/1415.html#L84'>handle</a>             84 dlfcn/dlinfo.c   struct dlinfo_args args = { handle, request, arg };</span>
<span class='curline'><a href='../S/1415.html#L90'>handle</a>             90 dlfcn/dlinfo.c ___dlinfo (void *handle, int request, void *arg)</span>
<span class='curline'><a href='../S/1415.html#L93'>handle</a>             93 dlfcn/dlinfo.c     return GLRO (dl_dlfcn_hook)-&gt;dlinfo (handle, request, arg);</span>
<span class='curline'><a href='../S/1415.html#L95'>handle</a>             95 dlfcn/dlinfo.c     return dlinfo_implementation (handle, request, arg);</span>
<span class='curline'><a href='../S/1415.html#L105'>handle</a>            105 dlfcn/dlinfo.c __dlinfo (void *handle, int request, void *arg)</span>
<span class='curline'><a href='../S/1415.html#L107'>handle</a>            107 dlfcn/dlinfo.c   return dlinfo_implementation (handle, request, arg);</span>
<span class='curline'><a href='../S/1467.html#L27'>handle</a>             27 dlfcn/dlsym.c    void *handle;</span>
<span class='curline'><a href='../S/1467.html#L40'>handle</a>             40 dlfcn/dlsym.c    args-&gt;sym = _dl_sym (args-&gt;handle, args-&gt;name, args-&gt;who);</span>
<span class='curline'><a href='../S/1467.html#L44'>handle</a>             44 dlfcn/dlsym.c  dlsym_implementation (void *handle, const char *name, void *dl_caller)</span>
<span class='curline'><a href='../S/1467.html#L48'>handle</a>             48 dlfcn/dlsym.c    args.handle = handle;</span>
<span class='curline'><a href='../S/1467.html#L63'>handle</a>             63 dlfcn/dlsym.c  ___dlsym (void *handle, const char *name)</span>
<span class='curline'><a href='../S/1467.html#L66'>handle</a>             66 dlfcn/dlsym.c      return GLRO (dl_dlfcn_hook)-&gt;dlsym (handle, name, RETURN_ADDRESS (0));</span>
<span class='curline'><a href='../S/1467.html#L68'>handle</a>             68 dlfcn/dlsym.c      return dlsym_implementation (handle, name, RETURN_ADDRESS (0));</span>
<span class='curline'><a href='../S/1467.html#L79'>handle</a>             79 dlfcn/dlsym.c  __dlsym (void *handle, const char *name, void *dl_caller)</span>
<span class='curline'><a href='../S/1467.html#L81'>handle</a>             81 dlfcn/dlsym.c    return dlsym_implementation (handle, name, dl_caller);</span>
<span class='curline'><a href='../S/1467.html#L85'>handle</a>             85 dlfcn/dlsym.c  ___dlsym (void *handle, const char *name)</span>
<span class='curline'><a href='../S/1467.html#L87'>handle</a>             87 dlfcn/dlsym.c    return __dlsym (handle, name, RETURN_ADDRESS (0));</span>
<span class='curline'><a href='../S/1471.html#L27'>handle</a>             27 dlfcn/dlvsym.c   void *handle;</span>
<span class='curline'><a href='../S/1471.html#L41'>handle</a>             41 dlfcn/dlvsym.c   args-&gt;sym = _dl_vsym (args-&gt;handle, args-&gt;name, args-&gt;version, args-&gt;who);</span>
<span class='curline'><a href='../S/1471.html#L45'>handle</a>             45 dlfcn/dlvsym.c dlvsym_implementation (void *handle, const char *name, const char *version,</span>
<span class='curline'><a href='../S/1471.html#L50'>handle</a>             50 dlfcn/dlvsym.c   args.handle = handle;</span>
<span class='curline'><a href='../S/1471.html#L66'>handle</a>             66 dlfcn/dlvsym.c ___dlvsym (void *handle, const char *name, const char *version)</span>
<span class='curline'><a href='../S/1471.html#L69'>handle</a>             69 dlfcn/dlvsym.c     return GLRO (dl_dlfcn_hook)-&gt;dlvsym (handle, name, version,</span>
<span class='curline'><a href='../S/1471.html#L72'>handle</a>             72 dlfcn/dlvsym.c     return dlvsym_implementation (handle, name, version, RETURN_ADDRESS (0));</span>
<span class='curline'><a href='../S/1471.html#L83'>handle</a>             83 dlfcn/dlvsym.c __dlvsym (void *handle, const char *name, const char *version, void *dl_caller)</span>
<span class='curline'><a href='../S/1471.html#L85'>handle</a>             85 dlfcn/dlvsym.c   return dlvsym_implementation (handle, name, version, dl_caller);</span>
<span class='curline'><a href='../S/1471.html#L89'>handle</a>             89 dlfcn/dlvsym.c ___dlvsym (void *handle, const char *name, const char *version)</span>
<span class='curline'><a href='../S/1471.html#L91'>handle</a>             91 dlfcn/dlvsym.c   return __dlvsym (handle, name, version, RETURN_ADDRESS (0));</span>
<span class='curline'><a href='../S/1426.html#L10'>handle</a>             10 dlfcn/failtestmod.c   void *handle;</span>
<span class='curline'><a href='../S/1426.html#L13'>handle</a>             13 dlfcn/failtestmod.c   handle = dlopen (NULL, RTLD_NOW);</span>
<span class='curline'><a href='../S/1426.html#L14'>handle</a>             14 dlfcn/failtestmod.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1426.html#L21'>handle</a>             21 dlfcn/failtestmod.c   dlsym (handle, "main");</span>
<span class='curline'><a href='../S/1426.html#L24'>handle</a>             24 dlfcn/failtestmod.c   dlclose (handle);</span>
<span class='curline'><a href='../S/1462.html#L16'>handle</a>             16 dlfcn/modstatic2.c   void *handle = dlopen ("modstatic2-nonexistent.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/1462.html#L17'>handle</a>             17 dlfcn/modstatic2.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1462.html#L22'>handle</a>             22 dlfcn/modstatic2.c   handle = dlopen ("modstatic2.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/1462.html#L23'>handle</a>             23 dlfcn/modstatic2.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1462.html#L30'>handle</a>             30 dlfcn/modstatic2.c   test2 = dlsym (handle, "test");</span>
<span class='curline'><a href='../S/1462.html#L102'>handle</a>            102 dlfcn/modstatic2.c   res = dlinfo (handle, RTLD_DI_LMID, &amp;lmid);</span>
<span class='curline'><a href='../S/1462.html#L141'>handle</a>            141 dlfcn/modstatic2.c   void *test3 = dlsymfn (handle, "test");</span>
<span class='curline'><a href='../S/1462.html#L154'>handle</a>            154 dlfcn/modstatic2.c   dlclose (handle);</span>
<span class='curline'><a href='../S/1462.html#L156'>handle</a>            156 dlfcn/modstatic2.c   handle = dlmopen (LM_ID_BASE, "modstatic2.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/1462.html#L157'>handle</a>            157 dlfcn/modstatic2.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1462.html#L162'>handle</a>            162 dlfcn/modstatic2.c   dlclose (handle);</span>
<span class='curline'><a href='../S/1462.html#L164'>handle</a>            164 dlfcn/modstatic2.c   handle = dlmopen (LM_ID_NEWLM, "modstatic2.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/1462.html#L165'>handle</a>            165 dlfcn/modstatic2.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1462.html#L173'>handle</a>            173 dlfcn/modstatic2.c   handle = dlopen ("modstatic.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/1462.html#L174'>handle</a>            174 dlfcn/modstatic2.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1462.html#L181'>handle</a>            181 dlfcn/modstatic2.c   test4 = dlsym (handle, "test");</span>
<span class='curline'><a href='../S/1462.html#L230'>handle</a>            230 dlfcn/modstatic2.c   dlclose (handle);</span>
<span class='curline'><a href='../S/1430.html#L33'>handle</a>             33 dlfcn/tst-dladdr.c   void *handle;</span>
<span class='curline'><a href='../S/1430.html#L39'>handle</a>             39 dlfcn/tst-dladdr.c   handle = dlopen ("glreflib1.so", RTLD_NOW);</span>
<span class='curline'><a href='../S/1430.html#L40'>handle</a>             40 dlfcn/tst-dladdr.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1430.html#L43'>handle</a>             43 dlfcn/tst-dladdr.c   sym = dlsym (handle, "ref1");</span>
<span class='curline'><a href='../S/1430.html#L68'>handle</a>             68 dlfcn/tst-dladdr.c   dlclose (handle);</span>
<span class='curline'><a href='../S/1458.html#L31'>handle</a>             31 dlfcn/tst-dlinfo.c   void *handle = dlopen ("glreflib3.so", RTLD_NOW);</span>
<span class='curline'><a href='../S/1458.html#L32'>handle</a>             32 dlfcn/tst-dlinfo.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1458.html#L36'>handle</a>             36 dlfcn/tst-dlinfo.c   if (dlinfo (handle, req, arg) != 0)					      \</span>
<span class='curline'><a href='../S/1458.html#L46'>handle</a>             46 dlfcn/tst-dlinfo.c       if (l != handle)</span>
<span class='curline'><a href='../S/1458.html#L48'>handle</a>             48 dlfcn/tst-dlinfo.c 	  printf ("bogus link_map? %p != %p\n", l, handle);</span>
<span class='curline'><a href='../S/1458.html#L81'>handle</a>             81 dlfcn/tst-dlinfo.c   if (dlinfo (handle, RTLD_DI_LMID, &amp;lmid) != 0)</span>
<span class='curline'><a href='../S/1458.html#L90'>handle</a>             90 dlfcn/tst-dlinfo.c   dlclose (handle);</span>
<span class='curline'><a href='../S/1440.html#L8'>handle</a>              8 dlfcn/tststatic.c   void *handle;</span>
<span class='curline'><a href='../S/1440.html#L12'>handle</a>             12 dlfcn/tststatic.c   handle = dlopen ("modstatic.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/1440.html#L13'>handle</a>             13 dlfcn/tststatic.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1440.html#L19'>handle</a>             19 dlfcn/tststatic.c   test = dlsym (handle, "test");</span>
<span class='curline'><a href='../S/1440.html#L33'>handle</a>             33 dlfcn/tststatic.c   dlclose (handle);</span>
<span class='curline'><a href='../S/1437.html#L12'>handle</a>             12 dlfcn/tststatic2.c   void *handle = dlopen ("modstatic2-nonexistent.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/1437.html#L13'>handle</a>             13 dlfcn/tststatic2.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1437.html#L18'>handle</a>             18 dlfcn/tststatic2.c   handle = dlopen ("modstatic2.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/1437.html#L19'>handle</a>             19 dlfcn/tststatic2.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1437.html#L26'>handle</a>             26 dlfcn/tststatic2.c   test = dlsym (handle, "test");</span>
<span class='curline'><a href='../S/1437.html#L93'>handle</a>             93 dlfcn/tststatic2.c   res = dlinfo (handle, RTLD_DI_LMID, &amp;lmid);</span>
<span class='curline'><a href='../S/1437.html#L139'>handle</a>            139 dlfcn/tststatic2.c   void *test2 = dlsymfn (handle, "test");</span>
<span class='curline'><a href='../S/1437.html#L152'>handle</a>            152 dlfcn/tststatic2.c   dlclose (handle);</span>
<span class='curline'><a href='../S/1437.html#L154'>handle</a>            154 dlfcn/tststatic2.c   handle = dlmopen (LM_ID_BASE, "modstatic2.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/1437.html#L155'>handle</a>            155 dlfcn/tststatic2.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1437.html#L160'>handle</a>            160 dlfcn/tststatic2.c   dlclose (handle);</span>
<span class='curline'><a href='../S/1437.html#L162'>handle</a>            162 dlfcn/tststatic2.c   handle = dlmopen (LM_ID_NEWLM, "modstatic2.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/1437.html#L163'>handle</a>            163 dlfcn/tststatic2.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1465.html#L37'>handle</a>             37 dlfcn/tststatic3.c   void *handle;</span>
<span class='curline'><a href='../S/1465.html#L40'>handle</a>             40 dlfcn/tststatic3.c   handle = dlopen ("modstatic3.so", RTLD_LAZY | RTLD_GLOBAL);</span>
<span class='curline'><a href='../S/1465.html#L41'>handle</a>             41 dlfcn/tststatic3.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1465.html#L48'>handle</a>             48 dlfcn/tststatic3.c   foop = dlsym (handle, "foo");</span>
<span class='curline'><a href='../S/1465.html#L55'>handle</a>             55 dlfcn/tststatic3.c   getfoo = dlsym (handle, "getfoo");</span>
<span class='curline'><a href='../S/1465.html#L62'>handle</a>             62 dlfcn/tststatic3.c   setfoo = dlsym (handle, "setfoo");</span>
<span class='curline'><a href='../S/1465.html#L122'>handle</a>            122 dlfcn/tststatic3.c   dlclose (handle);</span>
<span class='curline'><a href='../S/1448.html#L37'>handle</a>             37 dlfcn/tststatic5.c   void *handle;</span>
<span class='curline'><a href='../S/1448.html#L40'>handle</a>             40 dlfcn/tststatic5.c   handle = dlopen ("modstatic5.so", RTLD_LAZY | RTLD_LOCAL);</span>
<span class='curline'><a href='../S/1448.html#L41'>handle</a>             41 dlfcn/tststatic5.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1448.html#L48'>handle</a>             48 dlfcn/tststatic5.c   my_getpagesize = dlsym (handle, "my_getpagesize");</span>
<span class='curline'><a href='../S/1448.html#L65'>handle</a>             65 dlfcn/tststatic5.c   dlclose (handle);</span>
<span class='curline'><a href='../S/2578.html#L85'>handle</a>             85 elf/dl-sym.c   do_sym (void *handle, const char *name, void *who,</span>
<span class='curline'><a href='../S/2578.html#L95'>handle</a>             95 elf/dl-sym.c     if (handle == RTLD_DEFAULT)</span>
<span class='curline'><a href='../S/2578.html#L129'>handle</a>            129 elf/dl-sym.c     else if (handle == RTLD_NEXT)</span>
<span class='curline'><a href='../S/2578.html#L152'>handle</a>            152 elf/dl-sym.c         struct link_map *map = handle;</span>
<span class='curline'><a href='../S/2578.html#L178'>handle</a>            178 elf/dl-sym.c   _dl_vsym (void *handle, const char *name, const char *version, void *who)</span>
<span class='curline'><a href='../S/2578.html#L189'>handle</a>            189 elf/dl-sym.c     return do_sym (handle, name, who, &amp;vers, 0);</span>
<span class='curline'><a href='../S/2578.html#L193'>handle</a>            193 elf/dl-sym.c   _dl_sym (void *handle, const char *name, void *who)</span>
<span class='curline'><a href='../S/2578.html#L195'>handle</a>            195 elf/dl-sym.c     return do_sym (handle, name, who, NULL, DL_LOOKUP_RETURN_NEWEST);</span>
<span class='curline'><a href='../S/2630.html#L20'>handle</a>             20 elf/loadtest.c   void *handle;</span>
<span class='curline'><a href='../S/2630.html#L114'>handle</a>            114 elf/loadtest.c       if (testobjs[index].handle == NULL)</span>
<span class='curline'><a href='../S/2630.html#L119'>handle</a>            119 elf/loadtest.c 	  testobjs[index].handle = dlopen (testobjs[index].name,</span>
<span class='curline'><a href='../S/2630.html#L121'>handle</a>            121 elf/loadtest.c 	  if (testobjs[index].handle == NULL)</span>
<span class='curline'><a href='../S/2630.html#L126'>handle</a>            126 elf/loadtest.c 	  fct = dlsym (testobjs[index].handle, tests[nr].fname);</span>
<span class='curline'><a href='../S/2630.html#L135'>handle</a>            135 elf/loadtest.c 		  testobjs[index].name, testobjs[index].handle);</span>
<span class='curline'><a href='../S/2630.html#L139'>handle</a>            139 elf/loadtest.c 	  if (dlclose (testobjs[index].handle) != 0)</span>
<span class='curline'><a href='../S/2630.html#L146'>handle</a>            146 elf/loadtest.c 		    testobjs[index].name, testobjs[index].handle);</span>
<span class='curline'><a href='../S/2630.html#L148'>handle</a>            148 elf/loadtest.c 	  testobjs[index].handle = NULL;</span>
<span class='curline'><a href='../S/2630.html#L150'>handle</a>            150 elf/loadtest.c 	  if (testobjs[0].handle == NULL</span>
<span class='curline'><a href='../S/2630.html#L151'>handle</a>            151 elf/loadtest.c 	      &amp;&amp; testobjs[1].handle == NULL</span>
<span class='curline'><a href='../S/2630.html#L152'>handle</a>            152 elf/loadtest.c 	      &amp;&amp; testobjs[5].handle == NULL)</span>
<span class='curline'><a href='../S/2630.html#L174'>handle</a>            174 elf/loadtest.c     if (testobjs[count].handle != NULL)</span>
<span class='curline'><a href='../S/2630.html#L178'>handle</a>            178 elf/loadtest.c 		((struct link_map *) testobjs[count].handle)-&gt;l_initfini,</span>
<span class='curline'><a href='../S/2630.html#L179'>handle</a>            179 elf/loadtest.c 		((struct link_map *) testobjs[count].handle)-&gt;l_versions);</span>
<span class='curline'><a href='../S/2630.html#L181'>handle</a>            181 elf/loadtest.c 	if (dlclose (testobjs[count].handle) != 0)</span>
<span class='curline'><a href='../S/2727.html#L8'>handle</a>              8 elf/nodelete2.c   void *handle = dlopen ("nodel2mod3.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/2727.html#L9'>handle</a>              9 elf/nodelete2.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/2727.html#L14'>handle</a>             14 elf/nodelete2.c   dlclose (handle);</span>
<span class='curline'><a href='../S/2742.html#L8'>handle</a>              8 elf/reldep8.c    void *handle = dlopen ("reldep8mod3.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/2742.html#L9'>handle</a>              9 elf/reldep8.c    if (handle == NULL)</span>
<span class='curline'><a href='../S/2742.html#L14'>handle</a>             14 elf/reldep8.c    dlclose (handle);</span>
<span class='curline'><a href='../S/2521.html#L8'>handle</a>              8 elf/reldep9.c    void *handle = dlopen ("reldep9mod3.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/2521.html#L9'>handle</a>              9 elf/reldep9.c    if (handle == NULL)</span>
<span class='curline'><a href='../S/2521.html#L14'>handle</a>             14 elf/reldep9.c    dlclose (handle);</span>
<span class='curline'><a href='../S/2983.html#L10'>handle</a>             10 elf/tst-array4.c   void *handle = dlopen ("tst-array2dep.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/2983.html#L14'>handle</a>             14 elf/tst-array4.c   if (handle != NULL)</span>
<span class='curline'><a href='../S/2983.html#L15'>handle</a>             15 elf/tst-array4.c     dlclose (handle);</span>
<span class='curline'><a href='../S/2636.html#L75'>handle</a>             75 elf/tst-dlmodcount.c   void *handle;</span>
<span class='curline'><a href='../S/2636.html#L78'>handle</a>             78 elf/tst-dlmodcount.c   handle = dlopen (path, RTLD_LAZY);</span>
<span class='curline'><a href='../S/2636.html#L79'>handle</a>             79 elf/tst-dlmodcount.c   if (!handle)</span>
<span class='curline'><a href='../S/2636.html#L82'>handle</a>             82 elf/tst-dlmodcount.c   return handle;</span>
<span class='curline'><a href='../S/2636.html#L86'>handle</a>             86 elf/tst-dlmodcount.c unload (const char *path, void *handle)</span>
<span class='curline'><a href='../S/2636.html#L89'>handle</a>             89 elf/tst-dlmodcount.c   if (dlclose (handle) &lt; 0)</span>
<span class='curline'><a href='../S/2871.html#L46'>handle</a>             46 elf/tst-dlmopen-dlerror-mod.c   void *handle = dlopen (name, RTLD_NOW);</span>
<span class='curline'><a href='../S/2871.html#L47'>handle</a>             47 elf/tst-dlmopen-dlerror-mod.c   if (handle != NULL)</span>
<span class='curline'><a href='../S/3157.html#L27'>handle</a>             27 elf/tst-dlmopen-dlerror.c   void *handle = xdlmopen (LM_ID_NEWLM, "tst-dlmopen-dlerror-mod.so",</span>
<span class='curline'><a href='../S/3157.html#L29'>handle</a>             29 elf/tst-dlmopen-dlerror.c   void (*call_dlsym) (const char *name) = xdlsym (handle, "call_dlsym");</span>
<span class='curline'><a href='../S/3157.html#L30'>handle</a>             30 elf/tst-dlmopen-dlerror.c   void (*call_dlopen) (const char *name) = xdlsym (handle, "call_dlopen");</span>
<span class='curline'><a href='../S/2961.html#L24'>handle</a>             24 elf/tst-dlmopen-gethostbyname.c   void *handle = xdlmopen (LM_ID_NEWLM, "tst-dlmopen-gethostbyname-mod.so",</span>
<span class='curline'><a href='../S/2961.html#L26'>handle</a>             26 elf/tst-dlmopen-gethostbyname.c   void (*call_gethostbyname) (void) = xdlsym (handle, "call_gethostbyname");</span>
<span class='curline'><a href='../S/3135.html#L24'>handle</a>             24 elf/tst-dlopen-nodelete-reloc-mod10.c static void *handle;</span>
<span class='curline'><a href='../S/3135.html#L29'>handle</a>             29 elf/tst-dlopen-nodelete-reloc-mod10.c   handle = dlopen ("tst-dlopen-nodelete-reloc-mod11.so", RTLD_NOW);</span>
<span class='curline'><a href='../S/3135.html#L30'>handle</a>             30 elf/tst-dlopen-nodelete-reloc-mod10.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/3135.html#L40'>handle</a>             40 elf/tst-dlopen-nodelete-reloc-mod10.c   dlclose (handle);</span>
<span class='curline'><a href='../S/2585.html#L24'>handle</a>             24 elf/tst-dlopen-nodelete-reloc-mod8.c static void *handle;</span>
<span class='curline'><a href='../S/2585.html#L29'>handle</a>             29 elf/tst-dlopen-nodelete-reloc-mod8.c   handle = dlopen ("tst-dlopen-nodelete-reloc-mod9.so", RTLD_NOW);</span>
<span class='curline'><a href='../S/2585.html#L30'>handle</a>             30 elf/tst-dlopen-nodelete-reloc-mod8.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/2585.html#L40'>handle</a>             40 elf/tst-dlopen-nodelete-reloc-mod8.c   dlclose (handle);</span>
<span class='curline'><a href='../S/2501.html#L29'>handle</a>             29 elf/tst-dlopen-self.c   void *handle = dlopen (path, RTLD_LAZY);</span>
<span class='curline'><a href='../S/2501.html#L30'>handle</a>             30 elf/tst-dlopen-self.c   if (handle != NULL)</span>
<span class='curline'><a href='../S/2849.html#L50'>handle</a>             50 elf/tst-dlopen-tlsmodid.h   void *handle = dlopen (TST_DLOPEN_TLSMODID_PATH, RTLD_LAZY);</span>
<span class='curline'><a href='../S/2849.html#L51'>handle</a>             51 elf/tst-dlopen-tlsmodid.h   if (handle != NULL)</span>
<span class='curline'><a href='../S/3160.html#L47'>handle</a>             47 elf/tst-dlopenfail.c   void *handle = xdlopen ("tst-dlopenfailmod2.so", RTLD_NOW);</span>
<span class='curline'><a href='../S/3160.html#L48'>handle</a>             48 elf/tst-dlopenfail.c   xdlclose (handle);</span>
<span class='curline'><a href='../S/2683.html#L29'>handle</a>             29 elf/tst-dlsym-error.c test_one (void *handle, const char *name, void *(func) (void *, const char *),</span>
<span class='curline'><a href='../S/2683.html#L43'>handle</a>             43 elf/tst-dlsym-error.c   void *addr = func (handle, symbol);</span>
<span class='curline'><a href='../S/2683.html#L78'>handle</a>             78 elf/tst-dlsym-error.c   void *handle = dlopen (LIBC_SO, RTLD_LAZY);</span>
<span class='curline'><a href='../S/2683.html#L79'>handle</a>             79 elf/tst-dlsym-error.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/2683.html#L84'>handle</a>             84 elf/tst-dlsym-error.c   test_one (handle, name, func, suffix);</span>
<span class='curline'><a href='../S/2683.html#L85'>handle</a>             85 elf/tst-dlsym-error.c   dlclose (handle);</span>
<span class='curline'><a href='../S/2683.html#L89'>handle</a>             89 elf/tst-dlsym-error.c dlvsym_no_such_version (void *handle, const char *name)</span>
<span class='curline'><a href='../S/2683.html#L91'>handle</a>             91 elf/tst-dlsym-error.c   return dlvsym (handle, name, "NO_SUCH_VERSION");</span>
<span class='curline'><a href='../S/2683.html#L95'>handle</a>             95 elf/tst-dlsym-error.c dlvsym_glibc_private (void *handle, const char *name)</span>
<span class='curline'><a href='../S/2683.html#L97'>handle</a>             97 elf/tst-dlsym-error.c   return dlvsym (handle, name, "GLIBC_PRIVATE");</span>
<span class='curline'><a href='../S/2590.html#L47'>handle</a>             47 elf/tst-getauxval-static.c   void *handle = xdlopen ("tst-auxvalmod.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/2590.html#L48'>handle</a>             48 elf/tst-getauxval-static.c   void *ptr = xdlsym (handle, "getauxval_wrapper");</span>
<span class='curline'><a href='../S/2590.html#L62'>handle</a>             62 elf/tst-getauxval-static.c   xdlclose (handle);</span>
<span class='curline'><a href='../S/3022.html#L60'>handle</a>             60 elf/tst-glibc-hwcaps-prepend-cache.c     void *handle = xdlopen (SONAME, RTLD_NOW);</span>
<span class='curline'><a href='../S/3022.html#L61'>handle</a>             61 elf/tst-glibc-hwcaps-prepend-cache.c     int (*marker1) (void) = xdlsym (handle, "marker1");</span>
<span class='curline'><a href='../S/3022.html#L63'>handle</a>             63 elf/tst-glibc-hwcaps-prepend-cache.c     xdlclose (handle);</span>
<span class='curline'><a href='../S/3022.html#L76'>handle</a>             76 elf/tst-glibc-hwcaps-prepend-cache.c     void *handle = xdlopen (SONAME, RTLD_NOW);</span>
<span class='curline'><a href='../S/3022.html#L77'>handle</a>             77 elf/tst-glibc-hwcaps-prepend-cache.c     int (*marker1) (void) = xdlsym (handle, "marker1");</span>
<span class='curline'><a href='../S/3022.html#L79'>handle</a>             79 elf/tst-glibc-hwcaps-prepend-cache.c     xdlclose (handle);</span>
<span class='curline'><a href='../S/3022.html#L84'>handle</a>             84 elf/tst-glibc-hwcaps-prepend-cache.c     void *handle = xdlopen (SONAME, RTLD_NOW);</span>
<span class='curline'><a href='../S/3022.html#L85'>handle</a>             85 elf/tst-glibc-hwcaps-prepend-cache.c     int (*marker1) (void) = xdlsym (handle, "marker1");</span>
<span class='curline'><a href='../S/3022.html#L87'>handle</a>             87 elf/tst-glibc-hwcaps-prepend-cache.c     xdlclose (handle);</span>
<span class='curline'><a href='../S/3022.html#L99'>handle</a>             99 elf/tst-glibc-hwcaps-prepend-cache.c     void *handle = xdlopen (SONAME, RTLD_NOW);</span>
<span class='curline'><a href='../S/3022.html#L100'>handle</a>            100 elf/tst-glibc-hwcaps-prepend-cache.c     int (*marker1) (void) = xdlsym (handle, "marker1");</span>
<span class='curline'><a href='../S/3022.html#L102'>handle</a>            102 elf/tst-glibc-hwcaps-prepend-cache.c     xdlclose (handle);</span>
<span class='curline'><a href='../S/3022.html#L107'>handle</a>            107 elf/tst-glibc-hwcaps-prepend-cache.c     void *handle = xdlopen (SONAME, RTLD_NOW);</span>
<span class='curline'><a href='../S/3022.html#L108'>handle</a>            108 elf/tst-glibc-hwcaps-prepend-cache.c     int (*marker1) (void) = xdlsym (handle, "marker1");</span>
<span class='curline'><a href='../S/3022.html#L110'>handle</a>            110 elf/tst-glibc-hwcaps-prepend-cache.c     xdlclose (handle);</span>
<span class='curline'><a href='../S/3022.html#L123'>handle</a>            123 elf/tst-glibc-hwcaps-prepend-cache.c     void *handle = xdlopen (SONAME, RTLD_NOW);</span>
<span class='curline'><a href='../S/3022.html#L124'>handle</a>            124 elf/tst-glibc-hwcaps-prepend-cache.c     int (*marker1) (void) = xdlsym (handle, "marker1");</span>
<span class='curline'><a href='../S/3022.html#L126'>handle</a>            126 elf/tst-glibc-hwcaps-prepend-cache.c     xdlclose (handle);</span>
<span class='curline'><a href='../S/3082.html#L28'>handle</a>             28 elf/tst-initfinilazyfail.c   void *handle = dlopen ("tst-initlazyfailmod.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/3082.html#L29'>handle</a>             29 elf/tst-initfinilazyfail.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/3082.html#L32'>handle</a>             32 elf/tst-initfinilazyfail.c     FAIL_EXIT (2, "dlopen did not terminate the process (%p)", handle);</span>
<span class='curline'><a href='../S/3082.html#L38'>handle</a>             38 elf/tst-initfinilazyfail.c   void *handle = xdlopen ("tst-finilazyfailmod.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/3082.html#L39'>handle</a>             39 elf/tst-initfinilazyfail.c   int ret = dlclose (handle);</span>
<span class='curline'><a href='../S/3093.html#L29'>handle</a>             29 elf/tst-latepthread.c   void *handle = dlopen ("tst-latepthreadmod.so", RTLD_LOCAL | RTLD_LAZY);</span>
<span class='curline'><a href='../S/3093.html#L30'>handle</a>             30 elf/tst-latepthread.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/3093.html#L35'>handle</a>             35 elf/tst-latepthread.c   void *ptr = dlsym (handle, "trigger_dynlink_failure");</span>
<span class='curline'><a href='../S/3190.html#L28'>handle</a>             28 elf/tst-sonamemove-dlopen.c   void *handle = xdlopen ("tst-sonamemove-runmod1.so", RTLD_NOW);</span>
<span class='curline'><a href='../S/3190.html#L29'>handle</a>             29 elf/tst-sonamemove-dlopen.c   TEST_VERIFY (xdlsym (handle, "moved_function") != NULL);</span>
<span class='curline'><a href='../S/3190.html#L30'>handle</a>             30 elf/tst-sonamemove-dlopen.c   TEST_VERIFY (xdlvsym (handle, "moved_function", "SONAME_MOVE") != NULL);</span>
<span class='curline'><a href='../S/2170.html#L678'>handle</a>            678 hurd/hurdsig.c 	  if (act == handle &amp;&amp; threads[i] == ss-&gt;thread)</span>
<span class='curline'><a href='../S/2170.html#L793'>handle</a>            793 hurd/hurdsig.c       act = handle;</span>
<span class='curline'><a href='../S/2170.html#L863'>handle</a>            863 hurd/hurdsig.c 		act = handle;</span>
<span class='curline'><a href='../S/2170.html#L877'>handle</a>            877 hurd/hurdsig.c 	act = handle;</span>
<span class='curline'><a href='../S/2170.html#L982'>handle</a>            982 hurd/hurdsig.c     case handle:</span>
<span class='curline'><a href='../S/7079.html#L246'>handle</a>            246 iconv/gconv_cache.c 		      struct __gconv_step **handle, size_t *nsteps, int flags)</span>
<span class='curline'><a href='../S/7079.html#L309'>handle</a>            309 iconv/gconv_cache.c 	  *handle = result =</span>
<span class='curline'><a href='../S/7079.html#L369'>handle</a>            369 iconv/gconv_cache.c   *handle = result;</span>
<span class='curline'><a href='../S/7046.html#L124'>handle</a>            124 iconv/gconv_db.c 		   struct __gconv_step **handle, size_t *nsteps)</span>
<span class='curline'><a href='../S/7046.html#L134'>handle</a>            134 iconv/gconv_db.c   *handle = (*result)-&gt;steps;</span>
<span class='curline'><a href='../S/7046.html#L145'>handle</a>            145 iconv/gconv_db.c 		struct __gconv_step *handle, size_t nsteps)</span>
<span class='curline'><a href='../S/7046.html#L159'>handle</a>            159 iconv/gconv_db.c       new_deriv-&gt;steps = handle;</span>
<span class='curline'><a href='../S/7046.html#L230'>handle</a>            230 iconv/gconv_db.c 	   const char *fromset, struct __gconv_step **handle, size_t *nsteps)</span>
<span class='curline'><a href='../S/7046.html#L349'>handle</a>            349 iconv/gconv_db.c 	  *handle = NULL;</span>
<span class='curline'><a href='../S/7046.html#L354'>handle</a>            354 iconv/gconv_db.c 	*handle = result;</span>
<span class='curline'><a href='../S/7046.html#L359'>handle</a>            359 iconv/gconv_db.c       *handle = NULL;</span>
<span class='curline'><a href='../S/7046.html#L429'>handle</a>            429 iconv/gconv_db.c 		 struct __gconv_step **handle, size_t *nsteps)</span>
<span class='curline'><a href='../S/7046.html#L439'>handle</a>            439 iconv/gconv_db.c 			      handle, nsteps);</span>
<span class='curline'><a href='../S/7046.html#L443'>handle</a>            443 iconv/gconv_db.c       result = increment_counter (*handle, *nsteps);</span>
<span class='curline'><a href='../S/7046.html#L672'>handle</a>            672 iconv/gconv_db.c 			  fromset_expand ?: fromset, handle, nsteps);</span>
<span class='curline'><a href='../S/7046.html#L677'>handle</a>            677 iconv/gconv_db.c       *handle = NULL;</span>
<span class='curline'><a href='../S/7046.html#L683'>handle</a>            683 iconv/gconv_db.c 		  *handle, *nsteps);</span>
<span class='curline'><a href='../S/7046.html#L719'>handle</a>            719 iconv/gconv_db.c 			struct __gconv_step **handle, size_t *nsteps,</span>
<span class='curline'><a href='../S/7046.html#L732'>handle</a>            732 iconv/gconv_db.c   result = __gconv_lookup_cache (toset, fromset, handle, nsteps, flags);</span>
<span class='curline'><a href='../S/7046.html#L767'>handle</a>            767 iconv/gconv_db.c 			    handle, nsteps);</span>
<span class='curline'><a href='../S/7046.html#L776'>handle</a>            776 iconv/gconv_db.c 	  ? (*handle == NULL ? __GCONV_NOCONV : __GCONV_OK)</span>
<span class='curline'><a href='../S/7051.html#L92'>handle</a>             92 iconv/gconv_dl.c 	  found-&gt;handle = NULL;</span>
<span class='curline'><a href='../S/7051.html#L113'>handle</a>            113 iconv/gconv_dl.c 	  assert (found-&gt;handle == NULL);</span>
<span class='curline'><a href='../S/7051.html#L114'>handle</a>            114 iconv/gconv_dl.c 	  found-&gt;handle = __libc_dlopen (found-&gt;name);</span>
<span class='curline'><a href='../S/7051.html#L115'>handle</a>            115 iconv/gconv_dl.c 	  if (found-&gt;handle != NULL)</span>
<span class='curline'><a href='../S/7051.html#L117'>handle</a>            117 iconv/gconv_dl.c 	      found-&gt;fct = __libc_dlsym (found-&gt;handle, "gconv");</span>
<span class='curline'><a href='../S/7051.html#L127'>handle</a>            127 iconv/gconv_dl.c 		  found-&gt;init_fct = __libc_dlsym (found-&gt;handle, "gconv_init");</span>
<span class='curline'><a href='../S/7051.html#L128'>handle</a>            128 iconv/gconv_dl.c 		  found-&gt;end_fct = __libc_dlsym (found-&gt;handle, "gconv_end");</span>
<span class='curline'><a href='../S/7051.html#L144'>handle</a>            144 iconv/gconv_dl.c       else if (found-&gt;handle != NULL)</span>
<span class='curline'><a href='../S/7051.html#L168'>handle</a>            168 iconv/gconv_dl.c 	   &amp;&amp; --obj-&gt;counter &lt; -TRIES_BEFORE_UNLOAD &amp;&amp; obj-&gt;handle != NULL)</span>
<span class='curline'><a href='../S/7051.html#L171'>handle</a>            171 iconv/gconv_dl.c       __libc_dlclose (obj-&gt;handle);</span>
<span class='curline'><a href='../S/7051.html#L172'>handle</a>            172 iconv/gconv_dl.c       obj-&gt;handle = NULL;</span>
<span class='curline'><a href='../S/7051.html#L179'>handle</a>            179 iconv/gconv_dl.c __gconv_release_shlib (struct __gconv_loaded_object *handle)</span>
<span class='curline'><a href='../S/7051.html#L184'>handle</a>            184 iconv/gconv_dl.c   __twalk_r (loaded, do_release_shlib, handle);</span>
<span class='curline'><a href='../S/7051.html#L195'>handle</a>            195 iconv/gconv_dl.c   if (obj-&gt;handle != NULL)</span>
<span class='curline'><a href='../S/7051.html#L196'>handle</a>            196 iconv/gconv_dl.c     __libc_dlclose (obj-&gt;handle);</span>
<span class='curline'><a href='../S/7062.html#L51'>handle</a>             51 iconv/gconv_int.h   void *handle;</span>
<span class='curline'><a href='../S/7062.html#L151'>handle</a>            151 iconv/gconv_int.h                          __gconv_t *handle, int flags);</span>
<span class='curline'><a href='../S/7062.html#L191'>handle</a>            191 iconv/gconv_int.h 				   struct __gconv_step **handle,</span>
<span class='curline'><a href='../S/7062.html#L197'>handle</a>            197 iconv/gconv_int.h 				 struct __gconv_step **handle, size_t *nsteps,</span>
<span class='curline'><a href='../S/7062.html#L249'>handle</a>            249 iconv/gconv_int.h extern void __gconv_release_shlib (struct __gconv_loaded_object *handle)</span>
<span class='curline'><a href='../S/7060.html#L33'>handle</a>             33 iconv/gconv_open.c __gconv_open (struct gconv_spec *conv_spec, __gconv_t *handle,</span>
<span class='curline'><a href='../S/7060.html#L169'>handle</a>            169 iconv/gconv_open.c   *handle = result;</span>
<span class='curline'><a href='../S/18172.html#L58'>handle</a>             58 include/arpa/nameser.h #define ns_msg_getflag(handle, flag) \</span>
<span class='curline'><a href='../S/18172.html#L59'>handle</a>             59 include/arpa/nameser.h   (((handle)._flags &amp; _ns_flagdata[flag].mask) &gt;&gt; _ns_flagdata[flag].shift)</span>
<span class='curline'><a href='../S/18161.html#L80'>handle</a>             80 include/dlfcn.h extern void *_dl_sym (void *handle, const char *name, void *who)</span>
<span class='curline'><a href='../S/18161.html#L87'>handle</a>             87 include/dlfcn.h extern void *_dl_vsym (void *handle, const char *name, const char *version,</span>
<span class='curline'><a href='../S/18161.html#L103'>handle</a>            103 include/dlfcn.h   int (*dlclose) (void *handle);</span>
<span class='curline'><a href='../S/18161.html#L104'>handle</a>            104 include/dlfcn.h   void *(*dlsym) (void *handle, const char *name, void *dl_caller);</span>
<span class='curline'><a href='../S/18161.html#L105'>handle</a>            105 include/dlfcn.h   void *(*dlvsym) (void *handle, const char *name, const char *version,</span>
<span class='curline'><a href='../S/18161.html#L111'>handle</a>            111 include/dlfcn.h   int (*dlinfo) (void *handle, int request, void *arg);</span>
<span class='curline'><a href='../S/18161.html#L128'>handle</a>            128 include/dlfcn.h extern int __dlclose (void *handle);</span>
<span class='curline'><a href='../S/18161.html#L129'>handle</a>            129 include/dlfcn.h extern void *__dlsym (void *handle, const char *name, void *dl_caller);</span>
<span class='curline'><a href='../S/18161.html#L130'>handle</a>            130 include/dlfcn.h extern void *__dlvsym (void *handle, const char *name, const char *version,</span>
<span class='curline'><a href='../S/18161.html#L135'>handle</a>            135 include/dlfcn.h extern int __dlinfo (void *handle, int request, void *arg);</span>
<span class='curline'><a href='../S/1548.html#L40'>handle</a>             40 inet/idna.c      void *handle;</span>
<span class='curline'><a href='../S/1548.html#L52'>handle</a>             52 inet/idna.c      void *handle = __libc_dlopen (LIBIDN2_SONAME);</span>
<span class='curline'><a href='../S/1548.html#L53'>handle</a>             53 inet/idna.c      if (handle == NULL)</span>
<span class='curline'><a href='../S/1548.html#L62'>handle</a>             62 inet/idna.c        = __libc_dlvsym (handle, "idn2_lookup_ul", LIBIDN2_VERSION);</span>
<span class='curline'><a href='../S/1548.html#L64'>handle</a>             64 inet/idna.c        = __libc_dlvsym (handle, "idn2_to_unicode_lzlz", LIBIDN2_VERSION);</span>
<span class='curline'><a href='../S/1548.html#L67'>handle</a>             67 inet/idna.c          __libc_dlclose (handle);</span>
<span class='curline'><a href='../S/1548.html#L72'>handle</a>             72 inet/idna.c      result-&gt;handle = handle;</span>
<span class='curline'><a href='../S/1548.html#L87'>handle</a>             87 inet/idna.c      __libc_dlclose (functions-&gt;handle);</span>
<span class='curline'><a href='../S/18433.html#L55'>handle</a>             55 nptl/tst-stack4.c   void *handle[DSO_SHARED_FILES];</span>
<span class='curline'><a href='../S/18433.html#L68'>handle</a>             68 nptl/tst-stack4.c       handle[dso] = dlopen (dso_path[dso], RTLD_NOW);</span>
<span class='curline'><a href='../S/18433.html#L69'>handle</a>             69 nptl/tst-stack4.c       assert (handle[dso]);</span>
<span class='curline'><a href='../S/18433.html#L71'>handle</a>             71 nptl/tst-stack4.c       fun_vec[dso] = (function) dlsym (handle[dso], "function");</span>
<span class='curline'><a href='../S/18433.html#L108'>handle</a>            108 nptl/tst-stack4.c       dlclose (handle[dso]);</span>
<span class='curline'><a href='../S/1766.html#L94'>handle</a>             94 nss/nss_module.c           result-&gt;handle = NULL;</span>
<span class='curline'><a href='../S/1766.html#L136'>handle</a>            136 nss/nss_module.c       module-&gt;handle = NULL;</span>
<span class='curline'><a href='../S/1766.html#L181'>handle</a>            181 nss/nss_module.c   void *handle;</span>
<span class='curline'><a href='../S/1766.html#L191'>handle</a>            191 nss/nss_module.c     handle = __libc_dlopen (shlib_name);</span>
<span class='curline'><a href='../S/1766.html#L200'>handle</a>            200 nss/nss_module.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/1766.html#L237'>handle</a>            237 nss/nss_module.c           __libc_dlclose (handle);</span>
<span class='curline'><a href='../S/1766.html#L240'>handle</a>            240 nss/nss_module.c       pointers[idx] = __libc_dlsym (handle, function_name);</span>
<span class='curline'><a href='../S/1766.html#L263'>handle</a>            263 nss/nss_module.c 	= __libc_dlsym (handle, init_name);</span>
<span class='curline'><a href='../S/1766.html#L285'>handle</a>            285 nss/nss_module.c       module-&gt;handle = handle;</span>
<span class='curline'><a href='../S/1766.html#L293'>handle</a>            293 nss/nss_module.c       __libc_dlclose (handle);</span>
<span class='curline'><a href='../S/1766.html#L429'>handle</a>            429 nss/nss_module.c 	  &amp;&amp; current-&gt;handle != NULL)</span>
<span class='curline'><a href='../S/1766.html#L430'>handle</a>            430 nss/nss_module.c         __libc_dlclose (current-&gt;handle);</span>
<span class='curline'><a href='../S/1708.html#L75'>handle</a>             75 nss/nss_module.h   void *handle;</span>
<span class='curline'><a href='../S/6372.html#L114'>handle</a>            114 resolv/arpa/nameser.h #define ns_msg_id(handle) ((handle)._id + 0)</span>
<span class='curline'><a href='../S/6372.html#L115'>handle</a>            115 resolv/arpa/nameser.h #define ns_msg_base(handle) ((handle)._msg + 0)</span>
<span class='curline'><a href='../S/6372.html#L116'>handle</a>            116 resolv/arpa/nameser.h #define ns_msg_end(handle) ((handle)._eom + 0)</span>
<span class='curline'><a href='../S/6372.html#L117'>handle</a>            117 resolv/arpa/nameser.h #define ns_msg_size(handle) ((handle)._eom - (handle)._msg)</span>
<span class='curline'><a href='../S/6372.html#L118'>handle</a>            118 resolv/arpa/nameser.h #define ns_msg_count(handle, section) ((handle)._counts[section] + 0)</span>
<span class='curline'><a href='../S/6314.html#L60'>handle</a>             60 resolv/ns_parse.c int ns_msg_getflag(ns_msg handle, int flag) {</span>
<span class='curline'><a href='../S/6314.html#L61'>handle</a>             61 resolv/ns_parse.c 	return(((handle)._flags &amp; _ns_flagdata[flag].mask) &gt;&gt; _ns_flagdata[flag].shift);</span>
<span class='curline'><a href='../S/6314.html#L90'>handle</a>             90 resolv/ns_parse.c ns_initparse(const u_char *msg, int msglen, ns_msg *handle) {</span>
<span class='curline'><a href='../S/6314.html#L94'>handle</a>             94 resolv/ns_parse.c 	memset(handle, 0x5e, sizeof *handle);</span>
<span class='curline'><a href='../S/6314.html#L95'>handle</a>             95 resolv/ns_parse.c 	handle-&gt;_msg = msg;</span>
<span class='curline'><a href='../S/6314.html#L96'>handle</a>             96 resolv/ns_parse.c 	handle-&gt;_eom = eom;</span>
<span class='curline'><a href='../S/6314.html#L99'>handle</a>             99 resolv/ns_parse.c 	NS_GET16(handle-&gt;_id, msg);</span>
<span class='curline'><a href='../S/6314.html#L102'>handle</a>            102 resolv/ns_parse.c 	NS_GET16(handle-&gt;_flags, msg);</span>
<span class='curline'><a href='../S/6314.html#L106'>handle</a>            106 resolv/ns_parse.c 		NS_GET16(handle-&gt;_counts[i], msg);</span>
<span class='curline'><a href='../S/6314.html#L109'>handle</a>            109 resolv/ns_parse.c 		if (handle-&gt;_counts[i] == 0)</span>
<span class='curline'><a href='../S/6314.html#L110'>handle</a>            110 resolv/ns_parse.c 			handle-&gt;_sections[i] = NULL;</span>
<span class='curline'><a href='../S/6314.html#L113'>handle</a>            113 resolv/ns_parse.c 					  handle-&gt;_counts[i]);</span>
<span class='curline'><a href='../S/6314.html#L117'>handle</a>            117 resolv/ns_parse.c 			handle-&gt;_sections[i] = msg;</span>
<span class='curline'><a href='../S/6314.html#L122'>handle</a>            122 resolv/ns_parse.c 	setsection(handle, ns_s_max);</span>
<span class='curline'><a href='../S/6314.html#L128'>handle</a>            128 resolv/ns_parse.c ns_parserr(ns_msg *handle, ns_sect section, int rrnum, ns_rr *rr) {</span>
<span class='curline'><a href='../S/6314.html#L136'>handle</a>            136 resolv/ns_parse.c 	if (section != handle-&gt;_sect)</span>
<span class='curline'><a href='../S/6314.html#L137'>handle</a>            137 resolv/ns_parse.c 		setsection(handle, section);</span>
<span class='curline'><a href='../S/6314.html#L141'>handle</a>            141 resolv/ns_parse.c 		rrnum = handle-&gt;_rrnum;</span>
<span class='curline'><a href='../S/6314.html#L142'>handle</a>            142 resolv/ns_parse.c 	if (rrnum &lt; 0 || rrnum &gt;= handle-&gt;_counts[(int)section])</span>
<span class='curline'><a href='../S/6314.html#L144'>handle</a>            144 resolv/ns_parse.c 	if (rrnum &lt; handle-&gt;_rrnum)</span>
<span class='curline'><a href='../S/6314.html#L145'>handle</a>            145 resolv/ns_parse.c 		setsection(handle, section);</span>
<span class='curline'><a href='../S/6314.html#L146'>handle</a>            146 resolv/ns_parse.c 	if (rrnum &gt; handle-&gt;_rrnum) {</span>
<span class='curline'><a href='../S/6314.html#L147'>handle</a>            147 resolv/ns_parse.c 		b = ns_skiprr(handle-&gt;_msg_ptr, handle-&gt;_eom, section,</span>
<span class='curline'><a href='../S/6314.html#L148'>handle</a>            148 resolv/ns_parse.c 			      rrnum - handle-&gt;_rrnum);</span>
<span class='curline'><a href='../S/6314.html#L152'>handle</a>            152 resolv/ns_parse.c 		handle-&gt;_msg_ptr += b;</span>
<span class='curline'><a href='../S/6314.html#L153'>handle</a>            153 resolv/ns_parse.c 		handle-&gt;_rrnum = rrnum;</span>
<span class='curline'><a href='../S/6314.html#L157'>handle</a>            157 resolv/ns_parse.c 	b = __libc_dn_expand (handle-&gt;_msg, handle-&gt;_eom,</span>
<span class='curline'><a href='../S/6314.html#L158'>handle</a>            158 resolv/ns_parse.c 			      handle-&gt;_msg_ptr, rr-&gt;name, NS_MAXDNAME);</span>
<span class='curline'><a href='../S/6314.html#L161'>handle</a>            161 resolv/ns_parse.c 	handle-&gt;_msg_ptr += b;</span>
<span class='curline'><a href='../S/6314.html#L162'>handle</a>            162 resolv/ns_parse.c 	if (handle-&gt;_msg_ptr + NS_INT16SZ + NS_INT16SZ &gt; handle-&gt;_eom)</span>
<span class='curline'><a href='../S/6314.html#L164'>handle</a>            164 resolv/ns_parse.c 	NS_GET16(rr-&gt;type, handle-&gt;_msg_ptr);</span>
<span class='curline'><a href='../S/6314.html#L165'>handle</a>            165 resolv/ns_parse.c 	NS_GET16(rr-&gt;rr_class, handle-&gt;_msg_ptr);</span>
<span class='curline'><a href='../S/6314.html#L171'>handle</a>            171 resolv/ns_parse.c 		if (handle-&gt;_msg_ptr + NS_INT32SZ + NS_INT16SZ &gt; handle-&gt;_eom)</span>
<span class='curline'><a href='../S/6314.html#L173'>handle</a>            173 resolv/ns_parse.c 		NS_GET32(rr-&gt;ttl, handle-&gt;_msg_ptr);</span>
<span class='curline'><a href='../S/6314.html#L174'>handle</a>            174 resolv/ns_parse.c 		NS_GET16(rr-&gt;rdlength, handle-&gt;_msg_ptr);</span>
<span class='curline'><a href='../S/6314.html#L175'>handle</a>            175 resolv/ns_parse.c 		if (handle-&gt;_msg_ptr + rr-&gt;rdlength &gt; handle-&gt;_eom)</span>
<span class='curline'><a href='../S/6314.html#L177'>handle</a>            177 resolv/ns_parse.c 		rr-&gt;rdata = handle-&gt;_msg_ptr;</span>
<span class='curline'><a href='../S/6314.html#L178'>handle</a>            178 resolv/ns_parse.c 		handle-&gt;_msg_ptr += rr-&gt;rdlength;</span>
<span class='curline'><a href='../S/6314.html#L180'>handle</a>            180 resolv/ns_parse.c 	if (++handle-&gt;_rrnum &gt; handle-&gt;_counts[(int)section])</span>
<span class='curline'><a href='../S/6314.html#L181'>handle</a>            181 resolv/ns_parse.c 		setsection(handle, (ns_sect)((int)section + 1));</span>
<span class='curline'><a href='../S/6330.html#L67'>handle</a>             67 resolv/ns_print.c ns_sprintrr(const ns_msg *handle, const ns_rr *rr,</span>
<span class='curline'><a href='../S/6330.html#L73'>handle</a>             73 resolv/ns_print.c 	n = ns_sprintrrf(ns_msg_base(*handle), ns_msg_size(*handle),</span>
<span class='curline'><a href='../S/6277.html#L165'>handle</a>            165 resolv/res_debug.c do_section (int pfcode, ns_msg *handle, ns_sect section, int pflag, FILE *file)</span>
<span class='curline'><a href='../S/6277.html#L186'>handle</a>            186 resolv/res_debug.c 	opcode = (ns_opcode) ns_msg_getflag(*handle, ns_f_opcode);</span>
<span class='curline'><a href='../S/6277.html#L189'>handle</a>            189 resolv/res_debug.c 		if (ns_parserr(handle, section, rrnum, &amp;rr)) {</span>
<span class='curline'><a href='../S/6277.html#L207'>handle</a>            207 resolv/res_debug.c 			n = ns_sprintrr(handle, &amp;rr, NULL, NULL,</span>
<span class='curline'><a href='../S/6277.html#L242'>handle</a>            242 resolv/res_debug.c 	ns_msg handle;</span>
<span class='curline'><a href='../S/6277.html#L253'>handle</a>            253 resolv/res_debug.c 	if (ns_initparse(msg, len, &amp;handle) &lt; 0) {</span>
<span class='curline'><a href='../S/6277.html#L257'>handle</a>            257 resolv/res_debug.c 	opcode = ns_msg_getflag(handle, ns_f_opcode);</span>
<span class='curline'><a href='../S/6277.html#L258'>handle</a>            258 resolv/res_debug.c 	rcode = ns_msg_getflag(handle, ns_f_rcode);</span>
<span class='curline'><a href='../S/6277.html#L259'>handle</a>            259 resolv/res_debug.c 	id = ns_msg_id(handle);</span>
<span class='curline'><a href='../S/6277.html#L260'>handle</a>            260 resolv/res_debug.c 	qdcount = ns_msg_count(handle, ns_s_qd);</span>
<span class='curline'><a href='../S/6277.html#L261'>handle</a>            261 resolv/res_debug.c 	ancount = ns_msg_count(handle, ns_s_an);</span>
<span class='curline'><a href='../S/6277.html#L262'>handle</a>            262 resolv/res_debug.c 	nscount = ns_msg_count(handle, ns_s_ns);</span>
<span class='curline'><a href='../S/6277.html#L263'>handle</a>            263 resolv/res_debug.c 	arcount = ns_msg_count(handle, ns_s_ar);</span>
<span class='curline'><a href='../S/6277.html#L276'>handle</a>            276 resolv/res_debug.c 		if (ns_msg_getflag(handle, ns_f_qr))</span>
<span class='curline'><a href='../S/6277.html#L278'>handle</a>            278 resolv/res_debug.c 		if (ns_msg_getflag(handle, ns_f_aa))</span>
<span class='curline'><a href='../S/6277.html#L280'>handle</a>            280 resolv/res_debug.c 		if (ns_msg_getflag(handle, ns_f_tc))</span>
<span class='curline'><a href='../S/6277.html#L282'>handle</a>            282 resolv/res_debug.c 		if (ns_msg_getflag(handle, ns_f_rd))</span>
<span class='curline'><a href='../S/6277.html#L284'>handle</a>            284 resolv/res_debug.c 		if (ns_msg_getflag(handle, ns_f_ra))</span>
<span class='curline'><a href='../S/6277.html#L286'>handle</a>            286 resolv/res_debug.c 		if (ns_msg_getflag(handle, ns_f_z))</span>
<span class='curline'><a href='../S/6277.html#L288'>handle</a>            288 resolv/res_debug.c 		if (ns_msg_getflag(handle, ns_f_ad))</span>
<span class='curline'><a href='../S/6277.html#L290'>handle</a>            290 resolv/res_debug.c 		if (ns_msg_getflag(handle, ns_f_cd))</span>
<span class='curline'><a href='../S/6277.html#L310'>handle</a>            310 resolv/res_debug.c 	do_section (pfcode, &amp;handle, ns_s_qd, RES_PRF_QUES, file);</span>
<span class='curline'><a href='../S/6277.html#L311'>handle</a>            311 resolv/res_debug.c 	do_section (pfcode, &amp;handle, ns_s_an, RES_PRF_ANS, file);</span>
<span class='curline'><a href='../S/6277.html#L312'>handle</a>            312 resolv/res_debug.c 	do_section (pfcode, &amp;handle, ns_s_ns, RES_PRF_AUTH, file);</span>
<span class='curline'><a href='../S/6277.html#L313'>handle</a>            313 resolv/res_debug.c 	do_section (pfcode, &amp;handle, ns_s_ar, RES_PRF_ADD, file);</span>
<span class='curline'><a href='../S/6364.html#L29'>handle</a>             29 resolv/tst-resolv-ai_idn-latin1.c   void *handle = dlopen (LIBIDN2_SONAME, RTLD_LAZY);</span>
<span class='curline'><a href='../S/6364.html#L30'>handle</a>             30 resolv/tst-resolv-ai_idn-latin1.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/6364.html#L32'>handle</a>             32 resolv/tst-resolv-ai_idn-latin1.c   void *check_ver_sym = xdlsym (handle, "idn2_check_version");</span>
<span class='curline'><a href='../S/6364.html#L51'>handle</a>             51 resolv/tst-resolv-ai_idn-latin1.c   xdlclose (handle);</span>
<span class='curline'><a href='../S/6299.html#L126'>handle</a>            126 resolv/tst-resolv-ai_idn-nolibidn2.c   void *handle = xdlopen ("tst-no-libidn2.so", RTLD_LAZY);</span>
<span class='curline'><a href='../S/6299.html#L130'>handle</a>            130 resolv/tst-resolv-ai_idn-nolibidn2.c     TEST_VERIFY (handle2 == handle);</span>
<span class='curline'><a href='../S/6299.html#L147'>handle</a>            147 resolv/tst-resolv-ai_idn-nolibidn2.c   xdlclose (handle);</span>
<span class='curline'><a href='../S/6327.html#L28'>handle</a>             28 resolv/tst-resolv-ai_idn.c   void *handle = dlopen (LIBIDN2_SONAME, RTLD_LAZY);</span>
<span class='curline'><a href='../S/6327.html#L29'>handle</a>             29 resolv/tst-resolv-ai_idn.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/6327.html#L31'>handle</a>             31 resolv/tst-resolv-ai_idn.c   void *check_ver_sym = xdlsym (handle, "idn2_check_version");</span>
<span class='curline'><a href='../S/6327.html#L50'>handle</a>             50 resolv/tst-resolv-ai_idn.c   xdlclose (handle);</span>
<span class='curline'><a href='../S/6651.html#L52'>handle</a>             52 stdlib/tst-makecontext.c   void *handle;</span>
<span class='curline'><a href='../S/6651.html#L66'>handle</a>             66 stdlib/tst-makecontext.c   handle = dlopen (LIBGCC_S_SO, RTLD_LAZY);</span>
<span class='curline'><a href='../S/6651.html#L67'>handle</a>             67 stdlib/tst-makecontext.c   if (handle != NULL)</span>
<span class='curline'><a href='../S/6651.html#L69'>handle</a>             69 stdlib/tst-makecontext.c       unwind_backtrace = dlsym (handle, "_Unwind_Backtrace");</span>
<span class='curline'><a href='../S/6651.html#L75'>handle</a>             75 stdlib/tst-makecontext.c       dlclose (handle);</span>
<span class='curline'><a href='../S/5773.html#L35'>handle</a>             35 support/xdlfcn.c xdlsym (void *handle, const char *symbol)</span>
<span class='curline'><a href='../S/5773.html#L40'>handle</a>             40 support/xdlfcn.c   void *sym = dlsym (handle, symbol);</span>
<span class='curline'><a href='../S/5773.html#L55'>handle</a>             55 support/xdlfcn.c xdlvsym (void *handle, const char *symbol, const char *version)</span>
<span class='curline'><a href='../S/5773.html#L60'>handle</a>             60 support/xdlfcn.c   void *sym = dlvsym (handle, symbol, version);</span>
<span class='curline'><a href='../S/5773.html#L75'>handle</a>             75 support/xdlfcn.c xdlclose (void *handle)</span>
<span class='curline'><a href='../S/5773.html#L77'>handle</a>             77 support/xdlfcn.c   if (dlclose (handle) != 0)</span>
<span class='curline'><a href='../S/5905.html#L29'>handle</a>             29 support/xdlfcn.h void *xdlsym (void *handle, const char *symbol);</span>
<span class='curline'><a href='../S/5905.html#L30'>handle</a>             30 support/xdlfcn.h void *xdlvsym (void *handle, const char *symbol, const char *version);</span>
<span class='curline'><a href='../S/5905.html#L31'>handle</a>             31 support/xdlfcn.h void xdlclose (void *handle);</span>
<span class='curline'><a href='../S/7765.html#L29'>handle</a>             29 sysdeps/powerpc/tst-cache-ppc-static-dlopen.c   void *handle;</span>
<span class='curline'><a href='../S/7765.html#L32'>handle</a>             32 sysdeps/powerpc/tst-cache-ppc-static-dlopen.c   handle = dlopen ("mod-cache-ppc.so", RTLD_LAZY | RTLD_LOCAL);</span>
<span class='curline'><a href='../S/7765.html#L33'>handle</a>             33 sysdeps/powerpc/tst-cache-ppc-static-dlopen.c   if (handle == NULL)</span>
<span class='curline'><a href='../S/7765.html#L39'>handle</a>             39 sysdeps/powerpc/tst-cache-ppc-static-dlopen.c   test_cache = dlsym (handle, "test_cache");</span>
<span class='curline'><a href='../S/7765.html#L49'>handle</a>             49 sysdeps/powerpc/tst-cache-ppc-static-dlopen.c   dlclose (handle);</span>
<span class='curline'><a href='../S/10420.html#L25'>handle</a>             25 sysdeps/unix/sysv/linux/open_by_handle_at.c open_by_handle_at (int mount_fd, struct file_handle *handle, int flags)</span>
<span class='curline'><a href='../S/10420.html#L27'>handle</a>             27 sysdeps/unix/sysv/linux/open_by_handle_at.c   return SYSCALL_CANCEL (open_by_handle_at, mount_fd, handle, flags);</span>
</pre>
</body>
</html>
